{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"intro/","title":"Introduction","text":"<p>The Kyverno Envoy Plugin is a powerful tool that integrates the Kyverno-json policy engine with the Envoy proxy. It allows you to enforce Kyverno policies on incoming and outgoing traffic in a service mesh environment, providing an additional layer of security and control over your applications.</p>"},{"location":"intro/#overview","title":"Overview","text":"<p>Envoy is a Layer 7 proxy and communication bus tailored for large-scale, modern service-oriented architectures. Starting from version 1.7.0, Envoy includes an External Authorization filter that interfaces with an authorization service to determine the legitimacy of incoming requests.</p> <p>This functionality allows authorization decisions to be offloaded to an external service, which can access the request context. The request context includes details such as the origin and destination of the network activity, as well as specifics of the network request (e.g., HTTP request). This information enables the external service to make a well-informed decision regarding the authorization of the incoming request processed by Envoy.</p>"},{"location":"intro/#what-is-kyverno-envoy-plugin","title":"What is Kyverno-Envoy-Plugin?","text":"<p>Kyverno-envoy plugin extends Kyverno-json with a gRPC server that implements Envoy External Authorization API. This allows you to enforce Kyverno policies on incoming and outgoing traffic in a service mesh environment, providing an additional layer of security and control over your applications. You can use this version of Kyverno to enforce fine-grained, context-aware access control policies with Envoy without modifying your microservice.</p>"},{"location":"intro/#how-does-this-work","title":"How does this work?","text":"<p>In addition to the Envoy sidecar, your application pods will include a kyverno-envoy component, either as a sidecar or as a separate pod. This kyverno-envoy will be configured to communicate with the Kyverno-envoy-plugin gRPC server. When Envoy receives an API request intended for your microservice, it consults the Kyverno-envoy-plugin server to determine whether the request should be permitted.</p> <p>Performing policy evaluations locally with Envoy is advantageous, as it eliminates the need for an additional network hop for authorization checks, thus enhancing both performance and availability.</p> <p>Info</p> <p>The Kyverno-Envoy-Plugin is frequently deployed in Kubernetes environments as a sidecar container or as a separate pod. Additionally, it can be used in other environments as a standalone process running alongside Envoy.</p>"},{"location":"intro/#additional-resources","title":"Additional Resources","text":"<p>See the following pages on envoyproxy.io for more information on external authorization:</p> <ul> <li>External Authorization to learn about the External Authorization filter.</li> <li>Network and HTTP for details on configuring the External Authorization filter.</li> </ul>"},{"location":"jp/","title":"Overview","text":"<p><code>kyverno-json</code> uses JMESPath community edition, a modern JMESPath implementation with lexical scopes support.</p> <p>The current payload, policy and rule are always available using the following builtin bindings:</p> Binding Usage <code>$payload</code> Current payload being analysed <code>$policy</code> Current policy being executed <code>$rule</code> Current rule being evaluated <p>Warning</p> <p>No protection is made to prevent you from overriding those bindings.</p>"},{"location":"performance/","title":"Performance","text":"<p>This page offers guidance and best practices for benchmarking the performance of the kyverno-envoy-plugin, helping users understand the associated overhead. It outlines an example setup for conducting benchmarks, various benchmarking scenarios, and key metrics to capture for assessing the impact of the kyverno-envoy-plugin.</p>"},{"location":"performance/#benchmark-setup","title":"Benchmark Setup","text":"<p>The benchmark setup consists of the following components:</p>"},{"location":"performance/#sample-application","title":"Sample Application","text":"<p>The first component is a simple Go application that provides information of books in the library books collection and exposes APIs to <code>get</code>, <code>create</code> and <code>delete</code> books collection. Check this out for more information about the Go test application . </p>"},{"location":"performance/#envoy","title":"Envoy","text":"<p>The second component is the Envoy proxy, which runs alongside the example application. The Envoy configuration defines an external authorization filter <code>envoy.ext_authz</code> for a gRPC authorization server. The config uses Envoy's in-built gRPC client to make external gRPC calls.</p> <pre><code>static_resources:\n  listeners:\n  - address:\n      socket_address:\n        address: 0.0.0.0\n        port_value: 8000\n    filter_chains:\n    - filters:\n      - name: envoy.filters.network.http_connection_manager\n        typed_config:\n          \"@type\": type.googleapis.com/envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager\n          codec_type: auto\n          stat_prefix: ingress_http\n          route_config:\n            name: local_route\n            virtual_hosts:\n            - name: backend\n              domains:\n              - \"*\"\n              routes:\n              - match:\n                  prefix: \"/\"\n                route:\n                  cluster: service\n          http_filters:\n          - name: envoy.ext_authz\n            typed_config:\n              \"@type\": type.googleapis.com/envoy.extensions.filters.http.ext_authz.v3.ExtAuthz\n              transport_api_version: V3\n              with_request_body:\n                max_request_bytes: 8192\n                allow_partial_message: true\n              failure_mode_allow: false\n              grpc_service:\n                google_grpc:\n                  target_uri: 127.0.0.1:9191\n                  stat_prefix: ext_authz\n                timeout: 0.5s\n          - name: envoy.filters.http.router\n            typed_config:\n              \"@type\": type.googleapis.com/envoy.extensions.filters.http.router.v3.Router\n  clusters:\n  - name: service\n    connect_timeout: 0.25s\n    type: strict_dns\n    lb_policy: round_robin\n    load_assignment:\n      cluster_name: service\n      endpoints:\n      - lb_endpoints:\n        - endpoint:\n            address:\n              socket_address:\n                address: 127.0.0.1\n                port_value: 8080\nadmin:\n  access_log_path: \"/dev/null\"\n  address:\n    socket_address:\n      address: 0.0.0.0\n      port_value: 8001\nlayered_runtime:\n  layers:\n    - name: static_layer_0\n      static_layer:\n        envoy:\n          resource_limits:\n            listener:\n              example_listener_name:\n                connection_limit: 10000\n        overload:\n          global_downstream_max_connections: 50000\n</code></pre>"},{"location":"performance/#kyverno-envoy-plugin","title":"Kyverno-envoy-plugin","text":"<p>The third component is the <code>kyverno-envoy-plugin</code> itself, which is configured to load and enforce Kyverno policies on incoming requests. </p> <pre><code>containers:\n- name: kyverno-envoy-plugin\n  image: sanskardevops/plugin:0.0.34\n  imagePullPolicy: IfNotPresent\n  ports:\n    - containerPort: 8181\n    - containerPort: 9000\n  volumeMounts:\n    - readOnly: true\n      mountPath: /policies\n      name: policy-files\n  args:\n    - \"serve\"\n    - \"--policy=/policies/policy.yaml\"\n    - \"--address=:9000\"\n    - \"--healthaddress=:8181\"\n  livenessProbe:\n    httpGet:\n      path: /health\n      scheme: HTTP\n      port: 8181\n    initialDelaySeconds: 5\n    periodSeconds: 5\n  readinessProbe:\n    httpGet:\n      path: /health\n      scheme: HTTP\n      port: 8181\n    initialDelaySeconds: 5\n    periodSeconds: 5  \n</code></pre>"},{"location":"performance/#benchmark-scenarios","title":"Benchmark Scenarios","text":"<p>The following scenarios should be tested to compare the performance of the <code>kyverno-envoy-plugin</code> under different conditions:</p> <ol> <li>App Only: Requests are sent directly to the application, without Envoy or the <code>kyverno-envoy-plugin</code>.</li> <li>App and Envoy: Envoy is included in the request path, but the <code>kyverno-envoy-plugin</code> is not (i.e., Envoy External Authorization API is disabled).</li> <li>App, Envoy, and Kyverno (RBAC policy): Envoy External Authorization API is enabled, and a sample real-world RBAC policy is loaded into the <code>kyverno-envoy-plugin</code>.</li> </ol>"},{"location":"performance/#load-testing-with-k6","title":"Load Testing with k6","text":"<p>To perform load testing, we'll use the k6 tool. Follow these steps:</p> <ol> <li> <p>Install k6: Install k6 on your machine by following the instructions on the official website: https://k6.io/docs/getting-started/installation/</p> </li> <li> <p>Write the k6 script:  Below is the example k6 script. </p> </li> </ol> <pre><code>import http from 'k6/http';\nimport { check, group, sleep } from 'k6';\n\nexport const options = {\n  stages: [\n    { duration: '30s', target: 100 }, // Ramp-up to 100 virtual users over 30 seconds\n    { duration: '1m', target: 100 }, // Stay at 100 virtual users for 1 minute\n    { duration: '30s', target: 0 }, // Ramp-down to 0 virtual users over 30 seconds\n  ],\n};\n\n/*\nReplace ip for every scenerio\nexport SERVICE_PORT=$(kubectl -n demo get service testapp -o jsonpath='{.spec.ports[?(@.port==8080)].nodePort}')\nexport SERVICE_HOST=$(minikube ip)\nexport SERVICE_URL=$SERVICE_HOST:$SERVICE_PORT\necho $SERVICE_URL\n\nhttp://192.168.49.2:31541\n\n*/\nconst BASE_URL = 'http://192.168.49.2:31541'; \n\nexport default function () {\n  group('GET /book with guest token', () =&gt; {\n    const res = http.get(`${BASE_URL}/book`, {\n      headers: { 'Authorization': 'Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJleHAiOjIyNDEwODE1MzksIm5iZiI6MTUxNDg1MTEzOSwicm9sZSI6Imd1ZXN0Iiwic3ViIjoiWVd4cFkyVT0ifQ.ja1bgvIt47393ba_WbSBm35NrUhdxM4mOVQN8iXz8lk' },\n    });\n    check(res, {\n      'is status 200': (r) =&gt; r.status === 200,\n    });\n  });\n\n  sleep(1); // Sleep for 1 second between iterations\n}\n</code></pre> <ol> <li>Run the k6 test: Run the load test with the following command:</li> </ol> <p><pre><code>$ k6 run -f - &lt;&lt;EOF\nimport http from 'k6/http';\nimport { check, group, sleep } from 'k6';\n\nexport const options = {\n  stages: [\n    { duration: '30s', target: 100 }, // Ramp-up to 100 virtual users over 30 seconds\n    { duration: '1m', target: 100 }, // Stay at 100 virtual users for 1 minute\n    { duration: '30s', target: 0 }, // Ramp-down to 0 virtual users over 30 seconds\n  ],\n};\n\n\nconst BASE_URL = 'http://192.168.49.2:31700'; // Replace with your application URL \n\nexport default function () {\n  group('GET /book with guest token', () =&gt; {\n    const res = http.get(`${BASE_URL}/book`, {\n      headers: { 'Authorization': 'Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJleHAiOjIyNDEwODE1MzksIm5iZiI6MTUxNDg1MTEzOSwicm9sZSI6Imd1ZXN0Iiwic3ViIjoiWVd4cFkyVT0ifQ.ja1bgvIt47393ba_WbSBm35NrUhdxM4mOVQN8iXz8lk' },\n    });\n    check(res, {\n      'is status 200': (r) =&gt; r.status === 200,\n    });\n  });\n\n  sleep(1); // Sleep for 1 second between iterations\n}\nEOF\n</code></pre> 4. Analyze the results: Generate an json report with detailed insight by running:</p> <p><pre><code>k6 run --out json=report.json k6-script.js\n</code></pre> 5. ***Repeat for different scenarios**: </p> <ul> <li> </li> </ul> <p>running (2m00.6s), 000/100 VUs, 9048 complete and 0 interrupted iterations default \u2713 [======================================] 000/100 VUs  2m0s     ``` </p> <ul> <li> </li> </ul> <p>running (2m00.7s), 000/100 VUs, 9031 complete and 0 interrupted iterations default \u2713 [======================================] 000/100 VUs  2m0s     ```</p> <ul> <li> </li> </ul> <p>running (2m00.2s), 000/100 VUs, 8655 complete and 0 interrupted iterations default \u2713 [======================================] 000/100 VUs  2m0s     ```</p>"},{"location":"performance/#app-only","title":"App only","text":"<p>In this case , request are sent directly to the sample application ie no Envoy and Kyverno-plugin in the request path . For this run this command to apply the sample applicaition and then test with k6</p> <p><pre><code>$ kubectl apply -f https://raw.githubusercontent.com/kyverno/kyverno-envoy-plugin/main/tests/performance-test/manifest/app.yaml\n</code></pre> Results of the k6 when only application is applied ```bash</p> <pre><code>  /\\      |\u203e\u203e| /\u203e\u203e/   /\u203e\u203e/\n</code></pre> <p>/  /       |  |/  /   /  /   /  \\/        |     (   /   \u203e\u203e      /             |  |   |  (\u203e)  |    / __________   || _ __/ .io</p> <p>execution: local     script: k6-script.js     output: -</p> <p>scenarios: (100.00%) 1 scenario, 100 max VUs, 2m30s max duration (incl. graceful stop):           * default: Up to 100 looping VUs for 2m0s over 3 stages (gracefulRampDown: 30s, gracefulStop: 30s)</p> <p>\u2588 GET /book with guest token</p> <p>\u2713 is status 200</p> <p>checks.........................: 100.00% \u2713 9048      \u2717 0    data_received..................: 2.1 MB  18 kB/s  data_sent......................: 2.6 MB  21 kB/s  group_duration.................: avg=1.01ms   min=166.46\u00b5s med=775.01\u00b5s max=36ms    p(90)=1.72ms   p(95)=2.31ms  http_req_blocked...............: avg=15.08\u00b5s  min=1.55\u00b5s   med=6.54\u00b5s   max=4.09ms  p(90)=12.07\u00b5s  p(95)=15.25\u00b5s   http_req_connecting............: avg=4.58\u00b5s   min=0s       med=0s       max=1.57ms  p(90)=0s       p(95)=0s      http_req_duration..............: avg=745.73\u00b5s min=103.06\u00b5s med=549.17\u00b5s max=35.88ms p(90)=1.26ms   p(95)=1.75ms    { expected_response:true }...: avg=745.73\u00b5s min=103.06\u00b5s med=549.17\u00b5s max=35.88ms p(90)=1.26ms   p(95)=1.75ms  http_req_failed................: 0.00%   \u2713 0         \u2717 9048   http_req_receiving.............: avg=119.69\u00b5s min=11.33\u00b5s  med=77.78\u00b5s  max=10.97ms p(90)=193.73\u00b5s p(95)=285.58\u00b5s  http_req_sending...............: avg=41\u00b5s     min=6.96\u00b5s   med=31.12\u00b5s  max=2.39ms  p(90)=61.88\u00b5s  p(95)=78.15\u00b5s   http_req_tls_handshaking.......: avg=0s       min=0s       med=0s       max=0s      p(90)=0s       p(95)=0s      http_req_waiting...............: avg=585.04\u00b5s min=75.52\u00b5s  med=407.87\u00b5s max=35.84ms p(90)=965.49\u00b5s p(95)=1.33ms  http_reqs......................: 9048    75.050438/s  iteration_duration.............: avg=1s       min=1s       med=1s       max=1.06s   p(90)=1s       p(95)=1s      iterations.....................: 9048    75.050438/s  vus............................: 2       min=2       max=100  vus_max........................: 100     min=100     max=100</p>"},{"location":"performance/#app-and-envoy","title":"App and Envoy","text":"<p>In this case, Kyverno-envoy-plugin is not included in the path but Envoy is but Envoy External Authorization API disabled  For this run this command to apply the sample application with envoy.</p> <pre><code>$ kubectl apply -f https://raw.githubusercontent.com/kyverno/kyverno-envoy-plugin/main/tests/performance-test/manifest/app-envoy.yaml\n</code></pre> <p>Results of k6 after applying sample-application with envoy. ```bash</p> <pre><code>  /\\      |\u203e\u203e| /\u203e\u203e/   /\u203e\u203e/\n</code></pre> <p>/  /       |  |/  /   /  /   /  \\/        |     (   /   \u203e\u203e      /             |  |   |  (\u203e)  |    / __________   || _ __/ .io</p> <p>execution: local     script: k6-script.js     output: -</p> <p>scenarios: (100.00%) 1 scenario, 100 max VUs, 2m30s max duration (incl. graceful stop):           * default: Up to 100 looping VUs for 2m0s over 3 stages (gracefulRampDown: 30s, gracefulStop: 30s)</p> <p>\u2588 GET /book with guest token</p> <p>\u2713 is status 200</p> <p>checks.........................: 100.00% \u2713 9031      \u2717 0    data_received..................: 2.5 MB  21 kB/s  data_sent......................: 2.6 MB  21 kB/s  group_duration.................: avg=2.66ms  min=457.22\u00b5s med=1.8ms   max=65.53ms p(90)=4.85ms   p(95)=6.58ms  http_req_blocked...............: avg=12.81\u00b5s min=1.52\u00b5s   med=5.98\u00b5s  max=2.41ms  p(90)=11.84\u00b5s  p(95)=13.9\u00b5s  http_req_connecting............: avg=3.82\u00b5s  min=0s       med=0s      max=2.34ms  p(90)=0s       p(95)=0s      http_req_duration..............: avg=2.38ms  min=383.7\u00b5s  med=1.58ms  max=65.22ms p(90)=4.36ms   p(95)=5.92ms    { expected_response:true }...: avg=2.38ms  min=383.7\u00b5s  med=1.58ms  max=65.22ms p(90)=4.36ms   p(95)=5.92ms  http_req_failed................: 0.00%   \u2713 0         \u2717 9031   http_req_receiving.............: avg=136.3\u00b5s min=12.53\u00b5s  med=76.74\u00b5s max=12.75ms p(90)=183.23\u00b5s p(95)=272.91\u00b5s  http_req_sending...............: avg=41.54\u00b5s min=6.58\u00b5s   med=28.1\u00b5s  max=4.15ms  p(90)=59.62\u00b5s  p(95)=74.85\u00b5s   http_req_tls_handshaking.......: avg=0s      min=0s       med=0s      max=0s      p(90)=0s       p(95)=0s      http_req_waiting...............: avg=2.2ms   min=349.23\u00b5s med=1.43ms  max=65.08ms p(90)=4.05ms   p(95)=5.52ms  http_reqs......................: 9031    74.825497/s  iteration_duration.............: avg=1s      min=1s       med=1s      max=1.06s   p(90)=1s       p(95)=1s      iterations.....................: 9031    74.825497/s  vus............................: 3       min=3       max=100  vus_max........................: 100     min=100     max=100</p>"},{"location":"performance/#app-envoy-and-kyverno-envoy-plugin","title":"App, Envoy and Kyverno-envoy-plugin","text":"<p>In this case, performance measurements are observed with Envoy External Authorization API enabled and a sample real-world RBAC policy loaded into kyverno-envoy-plugin . For this apply this command to apply sample-application, envoy and kyverno-envoy-plugin</p> <pre><code>$ kubectl apply -f https://raw.githubusercontent.com/kyverno/kyverno-envoy-plugin/main/tests/performance-test/manifest/app-envoy-plugin.yaml\n</code></pre> <p>Results of k6 after applying sample-application, Envoy and kyverno-envoy-plugin .  ```console</p> <pre><code>  /\\      |\u203e\u203e| /\u203e\u203e/   /\u203e\u203e/\n</code></pre> <p>/  /       |  |/  /   /  /   /  \\/        |     (   /   \u203e\u203e      /             |  |   |  (\u203e)  |    / __________   || _ __/ .io</p> <p>execution: local     script: k6-script.js     output: -</p> <p>scenarios: (100.00%) 1 scenario, 100 max VUs, 2m30s max duration (incl. graceful stop):           * default: Up to 100 looping VUs for 2m0s over 3 stages (gracefulRampDown: 30s, gracefulStop: 30s)</p> <p>\u2588 GET /book with guest token</p> <p>\u2713 is status 200</p> <p>checks.........................: 100.00% \u2713 8655      \u2717 0    data_received..................: 2.4 MB  20 kB/s  data_sent......................: 2.4 MB  20 kB/s  group_duration.................: avg=46.54ms min=4.59ms  med=29.69ms max=337.79ms p(90)=109.35ms p(95)=140.51ms  http_req_blocked...............: avg=11.88\u00b5s min=1.21\u00b5s  med=4.15\u00b5s  max=2.83ms   p(90)=9.87\u00b5s   p(95)=11.4\u00b5s  http_req_connecting............: avg=4.98\u00b5s  min=0s      med=0s      max=2.18ms   p(90)=0s       p(95)=0s      http_req_duration..............: avg=46.37ms min=4.49ms  med=29.49ms max=337.69ms p(90)=109.26ms p(95)=140.28ms    { expected_response:true }...: avg=46.37ms min=4.49ms  med=29.49ms max=337.69ms p(90)=109.26ms p(95)=140.28ms  http_req_failed................: 0.00%   \u2713 0         \u2717 8655   http_req_receiving.............: avg=65.19\u00b5s min=11.14\u00b5s med=56.47\u00b5s max=5.58ms   p(90)=102.86\u00b5s p(95)=145.19\u00b5s  http_req_sending...............: avg=30.35\u00b5s min=5.43\u00b5s  med=18.48\u00b5s max=5.29ms   p(90)=46.63\u00b5s  p(95)=58\u00b5s    http_req_tls_handshaking.......: avg=0s      min=0s      med=0s      max=0s       p(90)=0s       p(95)=0s      http_req_waiting...............: avg=46.27ms min=4.43ms  med=29.42ms max=337.65ms p(90)=109.22ms p(95)=140.24ms  http_reqs......................: 8655    71.999297/s  iteration_duration.............: avg=1.04s   min=1s      med=1.03s   max=1.33s    p(90)=1.11s    p(95)=1.14s   iterations.....................: 8655    71.999297/s  vus............................: 2       min=2       max=100  vus_max........................: 100     min=100     max=100</p>"},{"location":"performance/#measuring-performance","title":"Measuring Performance","text":"<p>The following metrics should be measured to evaluate the performance impact of the <code>kyverno-envoy-plugin</code>:</p> <ul> <li> <p>End-to-end latency   The end-to-end latency represents the time taken for a request to complete, from the client sending the request to receiving the response. Based on the k6 results, the average end-to-end latency for the different scenarios is as follows:</p> </li> <li> <p>App Only: <code>avg=1.01ms</code> (from <code>group_duration</code> or <code>http_req_duration</code>)</p> </li> <li>App and Envoy: <code>avg=2.38ms</code> (from <code>http_req_duration</code>)</li> <li> <p>App, Envoy, and Kyverno-envoy-plugin: <code>avg=46.37ms</code> (from <code>http_req_duration</code>)</p> </li> <li> <p>Kyverno evaluation latency   The Kyverno evaluation latency represents the time taken by the kyverno-envoy-plugin to evaluate the request against the configured policies. While the k6 results do not directly provide this metric, an estimate can be inferred by analyzing the differences in latency between the \"App and Envoy\" scenario and the \"App, Envoy, and Kyverno-envoy-plugin\" scenario.</p> </li> </ul> <p>The difference in average latency between these two scenarios is:   <code>46.37ms</code> - <code>2.38ms</code> = <code>43.99ms</code></p> <p>This difference can be attributed to the Kyverno evaluation latency and the gRPC server handler latency combined. Assuming the gRPC server handler latency is relatively small compared to the Kyverno evaluation latency, the estimated range for the Kyverno evaluation latency is around 40ms to 45ms.</p> <ul> <li>Resource utilization   Refers to CPU and memory usage of the Kyverno-Envoy-Plugin container , <code>kubectl top</code> utility can be laveraged to measure the resource utilization.</li> </ul> <p>Get the resource utilization of the kyverno-envoy-plugin container using the following command:</p> <pre><code>$ kubectl top pod -n demo --containers\n</code></pre> <p>To monitor resource utilization overtime use the following command:</p> <pre><code>$ watch -n 1 \"kubectl top pod -n demo --containers\"\n</code></pre> <p>Now run the k6 script in different terminal window and observe the resource utilization of the kyverno-envoy-plugin container.</p> <p>Initial resource utilization of the kyverno-envoy-plugin container:</p> <pre><code>POD                        NAME                   CPU(cores)   MEMORY(bytes)\ntestapp-5955cd6f8b-dbvgd   envoy                  4m           70Mi\ntestapp-5955cd6f8b-dbvgd   kyverno-envoy-plugin   1m           51Mi\ntestapp-5955cd6f8b-dbvgd   test-application       1m           11Mi\n</code></pre> <p>Resource utilization of the kyverno-envoy-plugin container after 100 requests:</p> <pre><code>POD                        NAME                   CPU(cores)   MEMORY(bytes)\ntestapp-5955cd6f8b-dbvgd   envoy                  110m         70Mi\ntestapp-5955cd6f8b-dbvgd   kyverno-envoy-plugin   895m         60Mi\ntestapp-5955cd6f8b-dbvgd   test-application       17m          15Mi\n</code></pre> <p>Observations:</p> <ul> <li>The CPU utilization of the kyverno-envoy-plugin container increased significantly from 1m to 895m after receiving 100   requests during the load test.</li> <li>The memory utilization also increased, but to a lesser extent, from 51Mi to 60Mi.</li> </ul> <p>Resource utilization of the kyverno-envoy-plugin container after load completion:</p> <pre><code>POD                        NAME                   CPU(cores)   MEMORY(bytes)\ntestapp-5955cd6f8b-dbvgd   envoy                  4m           70Mi\ntestapp-5955cd6f8b-dbvgd   kyverno-envoy-plugin   1m           51Mi\ntestapp-5955cd6f8b-dbvgd   test-application       1m           11Mi\n</code></pre> <p>Observations:   - After the load test completed and the request volume returned to normal levels, the CPU and memory utilization of the kyverno-envoy-plugin container returned to their initial values. This indicates that the kyverno-envoy-plugin can efficiently handle the increased load during the test and release the additional resources when the load subsides.</p> <p>Correlation with k6 results:   - The k6 script simulated a load test scenario with 100 virtual users, ramping up over 30 seconds, staying at 100 users for 1 minute, and then ramping down over 30 seconds.   - During the load test, when the request volume was at its peak (100 virtual users), the kyverno-envoy-plugin container experienced a significant increase in CPU utilization, reaching 895m.   - This CPU utilization spike aligns with the increased processing demand on the kyverno-envoy-plugin to evaluate the incoming requests against the configured Kyverno policies.   - The memory utilization increase during the load test was relatively modest, suggesting that the policy evaluation did not significantly impact the memory requirements of the kyverno-envoy-plugin.</p>"},{"location":"quick-start/","title":"Quick Start","text":"<p>This section presumes testing is conducted with Envoy version 1.10.0 or newer.</p>"},{"location":"quick-start/#required-tools","title":"Required tools","text":"<ol> <li><code>minikube</code></li> <li><code>kubectl</code></li> </ol>"},{"location":"quick-start/#create-a-local-cluster","title":"Create a local cluster","text":"<p>Start minikube cluster with the following command:</p> <pre><code>minikube start\n</code></pre>"},{"location":"quick-start/#install-kyverno-envoy-sidecar-with-application","title":"Install kyverno-envoy sidecar with application","text":"<p>Install application with envoy and kyverno-envoy-plugin as a sidecar container.</p> <p><pre><code>kubectl apply -f https://raw.githubusercontent.com/kyverno/kyverno-envoy-plugin/main/quick_start.yaml \n</code></pre> The <code>applicaition.yaml</code> manifest defines the following resource:</p> <ul> <li> <p>The Deployment includes an example Go application that provides information of books in the library books collection and exposes APIs to <code>get</code>, <code>create</code> and <code>delete</code> books collection. Check this out for more information about the Go test application . </p> </li> <li> <p>The Deployment also includes a kyverno-envoy-plugin sidecar container in addition to the Envoy sidecar container. When Envoy recevies API request destined for the Go test applicaiton, it will check with kyverno-envoy-plugin to decide if the request should be allowed and the kyverno-envoy-plugin sidecar container is configured to query Kyverno-json engine for policy decisions on incoming requests.</p> </li> <li> <p>A ConfigMap <code>policy-config</code> is used to pass the policy to kyverno-envoy-plugin sidecar in the namespace <code>default</code> where the application is deployed .</p> </li> <li> <p>A ConfigMap <code>envoy-config</code> is used to pass an Envoy configuration with an External Authorization Filter to direct authorization checks to the kyverno-envoy-plugin sidecar. </p> </li> <li> <p>The Deployment also includes an init container that install iptables rules to redirect all container traffic to the Envoy proxy sidecar container , more about init container can be found here</p> </li> </ul>"},{"location":"quick-start/#make-test-application-accessible-in-the-cluster","title":"Make Test application accessible in the cluster .","text":"<pre><code>kubectl expose deployment testapp --type=NodePort --name=testapp-service --port=8080\n</code></pre>"},{"location":"quick-start/#set-the-service_url-environment-variable-to-the-services-ipport","title":"Set the <code>SERVICE_URL</code> environment variable to the service's IP/port.","text":"<p>minikube:</p> <pre><code>export SERVICE_PORT=$(kubectl get service testapp -o jsonpath='{.spec.ports[?(@.port==8080)].nodePort}')\nexport SERVICE_HOST=$(minikube ip)\nexport SERVICE_URL=$SERVICE_HOST:$SERVICE_PORT\necho $SERVICE_URL\n</code></pre>"},{"location":"quick-start/#calling-the-sample-test-application-and-verify-the-authorization","title":"Calling the sample test application and verify the authorization","text":"<p>For convenience, we\u2019ll want to store Alice\u2019s and Bob\u2019s tokens in environment variables. Here bob is assigned the admin role and alice is assigned the guest role.</p> <pre><code>export ALICE_TOKEN=\"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJleHAiOjIyNDEwODE1MzksIm5iZiI6MTUxNDg1MTEzOSwicm9sZSI6Imd1ZXN0Iiwic3ViIjoiWVd4cFkyVT0ifQ.ja1bgvIt47393ba_WbSBm35NrUhdxM4mOVQN8iXz8lk\"\nexport BOB_TOKEN=\"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJleHAiOjIyNDEwODE1MzksIm5iZiI6MTUxNDg1MTEzOSwicm9sZSI6ImFkbWluIiwic3ViIjoiWVd4cFkyVT0ifQ.veMeVDYlulTdieeX-jxFZ_tCmqQ_K8rwx2OktUHv5Z0\"\n</code></pre> <p>The policy we passed to kyverno-envoy-plugin sidecar in the ConfigMap <code>policy-config</code> is configured to check the conditions of the incoming request and denies the request if the user is a guest and the request method is <code>POST</code> at the <code>/book</code> path.</p> <pre><code>apiVersion: json.kyverno.io/v1alpha1\nkind: ValidatingPolicy\nmetadata:\n    name: checkrequest\nspec:\n    rules:\n    - name: deny-guest-request-at-post\n        assert:\n        any:\n        - message: \"POST method calls at path /book are not allowed to guests users\"\n            check:\n            request:\n                http:\n                    method: POST\n                    headers:\n                        authorization:\n                            (split(@, ' ')[1]):\n                                (jwt_decode(@ , 'secret').payload.role): admin\n                    path: /book                             \n        - message: \"GET method call is allowed to both guest and admin users\"\n            check:\n            request:\n                http:\n                    method: GET\n                    headers:\n                        authorization:\n                            (split(@, ' ')[1]):\n                                (jwt_decode(@ , 'secret').payload.role): admin\n                    path: /book \n        - message: \"GET method call is allowed to both guest and admin users\"\n            check:\n            request:\n                http:\n                    method: GET\n                    headers:\n                        authorization:\n                            (split(@, ' ')[1]):\n                                (jwt_decode(@ , 'secret').payload.role): guest\n                    path: /book               \n</code></pre> <p>Check for <code>Alice</code> which can get book but cannot create book.</p> <p><pre><code>curl -i -H \"Authorization: Bearer \"$ALICE_TOKEN\"\" http://$SERVICE_URL/book\n</code></pre> <pre><code>curl -i -H \"Authorization: Bearer \"$ALICE_TOKEN\"\" -d '{\"bookname\":\"Harry Potter\", \"author\":\"J.K. Rowling\"}' -H \"Content-Type: application/json\" -X POST http://$SERVICE_URL/book\n</code></pre> Check the <code>Bob</code> which can get book also create the book </p> <pre><code>curl -i -H \"Authorization: Bearer \"$BOB_TOKEN\"\" http://$SERVICE_URL/book\n</code></pre> <pre><code>curl -i -H \"Authorization: Bearer \"$BOB_TOKEN\"\" -d '{\"bookname\":\"Harry Potter\", \"author\":\"J.K. Rowling\"}' -H \"Content-Type: application/json\" -X POST http://$SERVICE_URL/book\n</code></pre> <p>Check on logs  <pre><code>kubectl logs \"$(kubectl get pod -l app=testapp -o jsonpath={.items..metadata.name})\" -c kyverno-envoy-plugin -f\n</code></pre> First , third and last request is passed but second request is failed.</p> <pre><code>sanskar@sanskar-HP-Laptop-15s-du1xxx:~$ kubectl logs \"$(kubectl get pod -l app=testapp -n demo -o jsonpath={.items..metadata.name})\" -n demo -c kyverno-envoy-plugin -f\nStarting HTTP server on Port 8000\nStarting GRPC server on Port 9000\nRequest is initialized in kyvernojson engine .\n2024/04/26 17:11:42 Request passed the deny-guest-request-at-post policy rule.\nRequest is initialized in kyvernojson engine .\n2024/04/26 17:22:11 Request violation: -&gt; POST method calls at path /book are not allowed to guests users\n -&gt; any[0].check.request.http.headers.authorization.(split(@, ' ')[1]).(jwt_decode(@ , 'secret').payload.role): Invalid value: \"guest\": Expected value: \"admin\"\n-&gt; GET method call is allowed to both guest and admin users\n -&gt; any[1].check.request.http.headers.authorization.(split(@, ' ')[1]).(jwt_decode(@ , 'secret').payload.role): Invalid value: \"guest\": Expected value: \"admin\"\n -&gt; any[1].check.request.http.method: Invalid value: \"POST\": Expected value: \"GET\"\n-&gt; GET method call is allowed to both guest and admin users\n -&gt; any[2].check.request.http.method: Invalid value: \"POST\": Expected value: \"GET\"\nRequest is initialized in kyvernojson engine .\n2024/04/26 17:23:13 Request passed the deny-guest-request-at-post policy rule.\nRequest is initialized in kyvernojson engine .\n2024/04/26 17:23:55 Request passed the deny-guest-request-at-post policy rule.\n</code></pre>"},{"location":"quick-start/#configuration","title":"Configuration","text":"<p>To deploy Kyverno-Envoy include the following container in your kubernetes Deployments:</p> <pre><code>- name: kyverno-envoy-plugin\n  image: sanskardevops/plugin:0.0.34\n  imagePullPolicy: IfNotPresent\n  ports:\n    - containerPort: 8181\n    - containerPort: 9000\n  volumeMounts:\n    - readOnly: true\n  args:\n    - \"serve\"\n    - \"--policy=/policies/policy.yaml\"\n    - \"--address=:9000\"\n    - \"--healthaddress=:8181\"\n  livenessProbe:\n    httpGet:\n      path: /health\n      scheme: HTTP\n      port: 8181\n    initialDelaySeconds: 5\n    periodSeconds: 5\n  readinessProbe:\n    httpGet:\n      path: /health\n      scheme: HTTP\n      port: 8181\n    initialDelaySeconds: 5\n    periodSeconds: 5  \n</code></pre>"},{"location":"jp/functions/","title":"Functions","text":""},{"location":"jp/functions/#built-in-functions","title":"built-in functions","text":"Name Signature abs <code>abs(number)</code> avg <code>avg(array[number])</code> ceil <code>ceil(number)</code> contains <code>contains(array\\|string, any)</code> ends_with <code>ends_with(string, string)</code> find_first <code>find_first(string, string, number, number)</code> find_last <code>find_last(string, string, number, number)</code> floor <code>floor(number)</code> from_items <code>from_items(array[array])</code> group_by <code>group_by(array, expref)</code> items <code>items(object)</code> join <code>join(string, array[string])</code> keys <code>keys(object)</code> length <code>length(string\\|array\\|object)</code> lower <code>lower(string)</code> map <code>map(expref, array)</code> max <code>max(array[number]\\|array[string])</code> max_by <code>max_by(array, expref)</code> merge <code>merge(object)</code> min <code>min(array[number]\\|array[string])</code> min_by <code>min_by(array, expref)</code> not_null <code>not_null(any)</code> pad_left <code>pad_left(string, number, string)</code> pad_right <code>pad_right(string, number, string)</code> replace <code>replace(string, string, string, number)</code> reverse <code>reverse(array\\|string)</code> sort <code>sort(array[string]\\|array[number])</code> sort_by <code>sort_by(array, expref)</code> split <code>split(string, string, number)</code> starts_with <code>starts_with(string, string)</code> sum <code>sum(array[number])</code> to_array <code>to_array(any)</code> to_number <code>to_number(any)</code> to_string <code>to_string(any)</code> trim <code>trim(string, string)</code> trim_left <code>trim_left(string, string)</code> trim_right <code>trim_right(string, string)</code> type <code>type(any)</code> upper <code>upper(string)</code> values <code>values(object)</code> zip <code>zip(array, array)</code>"},{"location":"jp/functions/#custom-functions","title":"custom functions","text":"Name Signature at <code>at(array, any)</code> concat <code>concat(string, string)</code> json_parse <code>json_parse(string)</code> wildcard <code>wildcard(string, string)</code>"},{"location":"jp/functions/#kyverno-functions","title":"kyverno functions","text":"Name Signature compare <code>compare(string, string)</code> equal_fold <code>equal_fold(string, string)</code> replace <code>replace(string, string, string, number)</code> replace_all <code>replace_all(string, string, string)</code> to_upper <code>to_upper(string)</code> to_lower <code>to_lower(string)</code> trim <code>trim(string, string)</code> trim_prefix <code>trim_prefix(string, string)</code> split <code>split(string, string)</code> regex_replace_all <code>regex_replace_all(string, string\\|number, string\\|number)</code> regex_replace_all_literal <code>regex_replace_all_literal(string, string\\|number, string\\|number)</code> regex_match <code>regex_match(string, string\\|number)</code> pattern_match <code>pattern_match(string, string\\|number)</code> label_match <code>label_match(object, object)</code> to_boolean <code>to_boolean(string)</code> add <code>add(any, any)</code> sum <code>sum(array)</code> subtract <code>subtract(any, any)</code> multiply <code>multiply(any, any)</code> divide <code>divide(any, any)</code> modulo <code>modulo(any, any)</code> round <code>round(number, number)</code> base64_decode <code>base64_decode(string)</code> base64_encode <code>base64_encode(string)</code> time_since <code>time_since(string, string, string)</code> time_now <code>time_now()</code> time_now_utc <code>time_now_utc()</code> path_canonicalize <code>path_canonicalize(string)</code> truncate <code>truncate(string, number)</code> semver_compare <code>semver_compare(string, string)</code> parse_json <code>parse_json(string)</code> parse_yaml <code>parse_yaml(string)</code> lookup <code>lookup(object\\|array, string\\|number)</code> items <code>items(object\\|array, string, string)</code> object_from_lists <code>object_from_lists(array, array)</code> random <code>random(string)</code> x509_decode <code>x509_decode(string)</code> time_to_cron <code>time_to_cron(string)</code> time_add <code>time_add(string, string)</code> time_parse <code>time_parse(string, string)</code> time_utc <code>time_utc(string)</code> time_diff <code>time_diff(string, string)</code> time_before <code>time_before(string, string)</code> time_after <code>time_after(string, string)</code> time_between <code>time_between(string, string, string)</code> time_truncate <code>time_truncate(string, string)</code>"},{"location":"policies/asserts/","title":"Assertion trees","text":"<p>Assertion trees can be used to apply complex and dynamic conditional checks using JMESPath expressions.</p>"},{"location":"policies/asserts/#assert","title":"Assert","text":"<p>An <code>assert</code> declaration contains an <code>any</code> or <code>all</code> list in which each entry contains a:</p> <ul> <li><code>check</code>: the assertion check</li> <li><code>message</code>: an optional message</li> </ul> <p>A check can contain one or more JMESPath expressions. Expressions represent projections of selected data in the JSON payload and the result of this projection is passed to descendants for further analysis.</p> <p>All comparisons happen in the leaves of the assertion tree.</p> <p>A simple example:</p> <p>This policy checks that a pod does not use the default service account:</p> <pre><code>apiVersion: json.kyverno.io/v1alpha1\nkind: ValidatingPolicy\nmetadata:\n  name: assert-sample\nspec:\n  rules:\n    - name: foo-bar\n      match:\n        all:\n        - apiVersion: v1\n          kind: Pod\n      assert:\n        all:\n        - message: \"serviceAccountName 'default' is not allowed\"\n          check:\n            spec:\n              (serviceAccountName == 'default'): false\n</code></pre> <p>A detailed example:</p> <p>Given the input payload below:</p> <pre><code>foo:\n  baz: true\n  bar: 4\n  bat: 6\n</code></pre> <p>It is possible to write a validation rule like this:</p> <pre><code>apiVersion: json.kyverno.io/v1alpha1\nkind: ValidatingPolicy\nmetadata:\n  name: test\nspec:\n  rules:\n    - name: foo-bar-4\n      validate:\n        assert:\n          all:\n          - message: \"...\"\n            check:\n              # project field `foo` onto itself, the content of `foo` becomes the current object for descendants\n              foo:\n\n                # evaluate expression `(bar &gt; `3`)`, the boolean result becomes the current object for descendants\n                # the `true` leaf is compared with the current value `true`\n                (bar &gt; `3`): true\n\n                # evaluate expression `(!baz)`, the boolean result becomes the current object for descendants\n                # the leaf `false` is compared with the current value `false`\n                (!baz): false\n\n                # evaluate expression `(bar + bat)`, the numeric result becomes the current object for descendants\n                # the leaf `10` is compared with the current value `10`\n                (bar + bat): 10\n</code></pre>"},{"location":"policies/asserts/#iterating-with-projection-modifiers","title":"Iterating with Projection Modifiers","text":"<p>Assertion tree expressions support modifiers to influence the way projected values are processed.</p> <p>The <code>~</code> modifier applies to arrays and maps, it mean the input array or map elements will be processed individually by descendants.</p> <p>When the <code>~</code> modifier is not used, descendants receive the whole array, not each individual element.</p> <p>Consider the following input document:</p> <pre><code>foo:\n  bar:\n  - 1\n  - 2\n  - 3\n</code></pre> <p>The policy below does not use the <code>~</code> modifier and <code>foo.bar</code> array is compared against the expected array:</p> <pre><code>apiVersion: json.kyverno.io/v1alpha1\nkind: ValidatingPolicy\nmetadata:\n  name: test\nspec:\n  rules:\n    - name: foo-bar\n      validate:\n        assert:\n          all:\n          - foo:\n              # the content of the `bar` field will be compared against `[1, 2, 3]`\n              bar:\n              - 1\n              - 2\n              - 3\n</code></pre> <p>With the <code>~</code> modifier, we can apply descendant assertions to all elements in the array individually. The policy below ensures that all elements in the input array are <code>&lt; 5</code>:</p> <pre><code>apiVersion: json.kyverno.io/v1alpha1\nkind: ValidatingPolicy\nmetadata:\n  name: test\nspec:\n  rules:\n    - name: foo-bar\n      validate:\n        assert:\n          all:\n          - foo:\n              # with the `~` modifier all elements in the `[1, 2, 3]` array are processed individually and passed to descendants\n              ~.bar:\n                # the expression `(@ &lt; `5`)` is evaluated for every element and the result is expected to be `true`\n                (@ &lt; `5`): true\n</code></pre> <p>The <code>~</code> modifier supports binding the index of the element being processed to a named binding with the following syntax <code>~index_name.bar</code>. When this is used, we can access the element index in descendants with <code>$index_name</code>.</p> <p>When used with a map, the named binding receives the key of the element being processed.</p>"},{"location":"policies/asserts/#explicit-bindings","title":"Explicit bindings","text":"<p>Sometimes it can be useful to refer to a parent node in the assertion tree.</p> <p>This is possible to add an explicit binding at every node in the tree by appending the <code>-&gt;binding_name</code> to the key.</p> <p>Given the input document:</p> <pre><code>foo:\n  bar: 4\n  bat: 6\n</code></pre> <p>The following policy will compute a sum and bind the result to the <code>sum</code> binding. A descendant can then use <code>$sum</code> and use it:</p> <pre><code>apiVersion: json.kyverno.io/v1alpha1\nkind: ValidatingPolicy\nmetadata:\n  name: test\nspec:\n  rules:\n    - name: foo-bar\n      validate:\n        assert:\n          all:\n          - foo:\n              # evaluate expression `(bar + bat)` and bind it to `sum`\n              (bar + bat)-&gt;sum:\n                # get the `$sum` binding and compare it against `10`\n                ($sum): 10\n</code></pre> <p>All binding are available to descendants, if a descendant creates a binding with a name that already exists the binding will be overridden for descendants only and it doesn't affect the bindings at upper levels in the tree.</p> <p>In other words, a node in the tree always sees bindings that are defined in the parents and if a name is reused, the first binding with the given name wins when winding up the tree.</p> <p>As a consequence, the policy below will evaluate to true:</p> <pre><code>apiVersion: json.kyverno.io/v1alpha1\nkind: ValidatingPolicy\nmetadata:\n  name: test\nspec:\n  rules:\n    - name: foo-bar\n      validate:\n        assert:\n          all:\n          - foo:\n              (bar + bat)-&gt;sum:\n                ($sum + $sum)-&gt;sum:\n                  ($sum): 20\n                ($sum): 10\n</code></pre> <p>Finally, we can always access the current payload, policy and rule being evaluated using the built-in <code>$payload</code>, <code>$policy</code> and <code>$rule</code> bindings. No protection is made to prevent you from overriding those bindings though.</p>"},{"location":"policies/asserts/#escaping-projection","title":"Escaping projection","text":"<p>It can be necessary to prevent a projection under certain circumstances.</p> <p>Consider the following document:</p> <pre><code>foo:\n  (bar): 4\n  (baz):\n  - 1\n  - 2\n  - 3\n</code></pre> <p>Here the <code>(bar)</code> key conflict with the projection syntax. To workaround this situation, you can escape a projection by surrounding it with <code>\\</code> characters like this:</p> <pre><code>apiVersion: json.kyverno.io/v1alpha1\nkind: ValidatingPolicy\nmetadata:\n  name: test\nspec:\n  rules:\n    - name: foo-bar\n      validate:\n        assert:\n          all:\n          - foo:\n              \\(bar)\\: 10\n</code></pre> <p>In this case, the leading and trailing <code>\\</code> characters will be erased and the projection won't be applied.</p> <p>Note that it's still possible to use the <code>~</code> modifier or to create a named binding with and escaped projection.</p> <p>Keys like this are perfectly valid:</p> <ul> <li><code>~index.\\baz\\</code></li> <li><code>\\baz\\@foo</code></li> <li><code>~index.\\baz\\@foo</code></li> </ul>"},{"location":"policies/authz-policy/","title":"Policy Reference","text":"<p>This page provides guidance on writing policies for request content processed by the kyverno-json validating policy, utilizing Envoy\u2019s External Authorization filter.</p>"},{"location":"policies/authz-policy/#writing-policies","title":"Writing Policies","text":"<p>Let start with an example policy that restricts access to an endpoint based on user's role and permissions.</p> <pre><code>apiVersion: json.kyverno.io/v1alpha1\nkind: ValidatingPolicy\nmetadata:\n    name: checkrequest\nspec:\n    rules:\n    - name: deny-guest-request-at-post\n        assert:\n        any:\n        - message: \"POST method calls at path /book are not allowed to guests users\"\n            check:\n            request:\n                http:\n                    method: POST\n                    headers:\n                        authorization:\n                            (split(@, ' ')[1]):\n                                (jwt_decode(@ , 'secret').payload.role): admin\n                    path: /book                             \n        - message: \"GET method call is allowed to both guest and admin users\"\n            check:\n            request:\n                http:\n                    method: GET\n                    headers:\n                        authorization:\n                            (split(@, ' ')[1]):\n                                (jwt_decode(@ , 'secret').payload.role): admin\n                    path: /book \n        - message: \"GET method call is allowed to both guest and admin users\"\n            check:\n            request:\n                http:\n                    method: GET\n                    headers:\n                        authorization:\n                            (split(@, ' ')[1]):\n                                (jwt_decode(@ , 'secret').payload.role): guest\n                    path: /book  \n</code></pre> <p>The above policy uses the <code>jwt_decode</code> builtin function to parse and verify the JWT containing information about the user making the request. it uses other builtins like <code>split</code>, <code>base64_decode</code>, <code>campare</code>, <code>contains</code> etc kyverno has many different function which can be used in policy.</p> <p>Sample input recevied by kyverno-json validating policy is shown below:</p> <pre><code>{\n  \"source\": {\n    \"address\": {\n      \"socketAddress\": {\n        \"address\": \"10.244.1.10\",\n        \"portValue\": 59252\n      }\n    }\n  },\n  \"destination\": {\n    \"address\": {\n      \"socketAddress\": {\n        \"address\": \"10.244.1.4\",\n        \"portValue\": 8080\n      }\n    }\n  },\n  \"request\": {\n    \"time\": \"2024-04-09T07:42:29.634453Z\",\n    \"http\": {\n      \"id\": \"14694995155993896575\",\n      \"method\": \"GET\",\n      \"headers\": {\n        \":authority\": \"testapp.demo.svc.cluster.local:8080\",\n        \":method\": \"GET\",\n        \":path\": \"/book\",\n        \":scheme\": \"http\",\n        \"authorization\": \"Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJleHAiOjIyNDEwODE1MzksIm5iZiI6MTUxNDg1MTEzOSwicm9sZSI6Imd1ZXN0Iiwic3ViIjoiWVd4cFkyVT0ifQ.ja1bgvIt47393ba_WbSBm35NrUhdxM4mOVQN8iXz8lk\",\n        \"user-agent\": \"Wget\",\n        \"x-forwarded-proto\": \"http\",\n        \"x-request-id\": \"27cd2724-e0f4-4a69-a1b1-9a94edfa31bb\"\n      },\n      \"path\": \"/book\",\n      \"host\": \"echo.demo.svc.cluster.local:8080\",\n      \"scheme\": \"http\",\n      \"protocol\": \"HTTP/1.1\"\n    }\n  },\n  \"metadataContext\": {},\n  \"routeMetadataContext\": {}\n}\n</code></pre> <p>With the help of assertion tree, we can write policies that can be used to validate the request content. </p> <p>An <code>assert</code> declaration contains an <code>any</code> or <code>all</code> list in which each entry contains a <code>check</code> and a <code>message</code>. The <code>check</code> contains a JMESPath expression that is evaluated against the request content. The <code>message</code> is a string that is returned when the check fails. A check can contain one or more JMESPath expressions. Expressions represent projections of seleted data in the JSON payload and the result of this projection is passed to descendants for futher analysis. All comparisons happen in the leaves of the assertion tree.</p> <p>For more detail checkout Policy Structure and Assertion trees.</p> <ul> <li>HTTP method <code>request.http.method</code></li> <li>Request path <code>request.http.path</code></li> <li>Authorization header <code>request.http.headers.authorization</code></li> </ul> <p>when we decode this above mentioned JWT token in the request payload we get payload.role <code>guest</code>:</p> <p><pre><code>{\n  \"exp\": 2241081539,\n  \"nbf\": 1514851139,\n  \"role\": \"guest\",\n  \"sub\": \"YWxpY2U=\"\n}\n</code></pre> With the input value above, the answer is: <pre><code>true\n</code></pre></p>"},{"location":"policies/policies/","title":"Policy Structure","text":"<p>Kyverno policies are Kubernetes resources and can be easily managed via Kubernetes APIs, GitOps workflows, and other existing tools.</p> <p>Policies that apply to JSON payload have a few differences from Kyverno policies that are applied to Kubernetes resources at admission controls.</p>"},{"location":"policies/policies/#resource-scope","title":"Resource Scope","text":"<p>Policies that apply to JSON payloads are always cluster-wide resources.</p>"},{"location":"policies/policies/#api-group-and-kind","title":"API Group and Kind","text":"<p><code>kyverno-json</code> policies belong to the <code>json.kyverno.io</code> group and can only be of kind <code>ValidatingPolicy</code>.</p> <pre><code>apiVersion: json.kyverno.io/v1alpha1\nkind: ValidatingPolicy\nmetadata:\n  name: test\nspec:\n  rules:\n    - name: foo-bar-4\n      validate:\n        assert:\n          all:\n          - foo:\n              bar: 4\n</code></pre>"},{"location":"policies/policies/#policy-rules","title":"Policy Rules","text":"<p>A policy can have multiple rules, and rules are processed in order. Evaluation stops at the first rule that fails.</p>"},{"location":"policies/policies/#match-and-exclude","title":"Match and Exclude","text":"<p>Policies that apply to JSON payloads use assertion trees in both the <code>match</code>/<code>exclude</code> declarations as well as the <code>validate</code> rule declaration.</p> <pre><code>apiVersion: json.kyverno.io/v1alpha1\nkind: ValidatingPolicy\nmetadata:\n  name: required-s3-tags\nspec:\n  rules:\n    - name: require-team-tag\n      identifier: address\n      match:\n        any:\n        - type: aws_s3_bucket\n      exclude:\n        any:\n        - name: bypass-me\n      validate:\n        assert:\n          all:\n          - values:\n              tags:\n                Team: ?*\n</code></pre> <p>In the example above, every resource having <code>type: aws_s3_bucket</code> will match, and payloads having <code>name: bypass-me</code> will be excluded.</p>"},{"location":"policies/policies/#identifying-payload-entries","title":"Identifying Payload Entries","text":"<p>A policy rule can contain an optional <code>identifier</code> which declares the path to the payload element that uniquely identifies each entry.</p>"},{"location":"policies/policies/#context-entries","title":"Context Entries","text":"<p>A policy rule can contain optional <code>context</code> entries that are made available to the rule via bindings:</p> <pre><code>apiVersion: json.kyverno.io/v1alpha1\nkind: ValidatingPolicy\nmetadata:\n  name: required-s3-tags\nspec:\n  rules:\n    - name: require-team-tag\n      match:\n        any:\n        - type: aws_s3_bucket\n      context:\n      # creates a `expectedTeam` binding automatically\n      - name: expectedTeam\n        variable: Kyverno\n      validate:\n        message: Bucket `{{ name }}` does not have the required Team tag {{ $expectedTeam }}\n        assert:\n          all:\n          - values:\n              tags:\n                # use the `$expectedTeam` binding coming from the context\n                Team: ($expectedTeam)\n</code></pre>"},{"location":"policies/policies/#no-foreach-pattern-operators-anchors-or-wildcards","title":"No <code>forEach</code>, <code>pattern operators</code>, <code>anchors</code>, or <code>wildcards</code>","text":"<p>The use of assertion trees addresses some features of Kyverno policies that apply to Kubernetes resources.</p> <p>Specifically, forEach, pattern operators, anchors, or wildcards are not supported for policies that apply to JSON resources. Instead, assertion trees with JMESPath expressions are used to achieve the same powerful features.</p>"},{"location":"tutorials/istio/","title":"Istio","text":"<p>Istio is an open source service mesh for managing the different microservices that make up a cloud-native application. Istio provides a mechanism to use a service as an external authorizer with the AuthorizationPolicy API.</p> <p>This tutorial shows how Istio\u2019s AuthorizationPolicy can be configured to delegate authorization decisions to Kyverno-envoy-plugin.</p>"},{"location":"tutorials/istio/#prerequisites","title":"Prerequisites","text":"<p>This tutorial requires Kubernetes 1.20 or later. To run the tutorial locally ensure you start a cluster with Kubernetes version 1.20+, we recommend using minikube or KIND.</p> <p>The tutorial also requries istio v1.19.0 or later. To install istio, follow the instructions here or run the below script it will create a kind cluster and install istio</p> <p><pre><code>#!/bin/bash\n\nKIND_IMAGE=kindest/node:v1.29.2\nISTIO_REPO=https://istio-release.storage.googleapis.com/charts\nISTIO_NS=istio-system\n\n# Create Kind cluster\nkind create cluster --image $KIND_IMAGE --wait 1m --config - &lt;&lt;EOF\nkind: Cluster\napiVersion: kind.x-k8s.io/v1alpha4\nnodes:\n  - role: control-plane\n    kubeadmConfigPatches:\n      - |-\n        kind: InitConfiguration\n        nodeRegistration:\n          kubeletExtraArgs:\n            node-labels: \"ingress-ready=true\"\n    extraPortMappings:\n      - containerPort: 80\n        hostPort: 80\n        protocol: TCP\n      - containerPort: 443\n        hostPort: 443\n        protocol: TCP\n  - role: worker\nEOF\n\n# Install Istio components\nhelm upgrade --install istio-base       --namespace $ISTIO_NS           --create-namespace --wait --repo $ISTIO_REPO base\nhelm upgrade --install istiod           --namespace $ISTIO_NS           --create-namespace --wait --repo $ISTIO_REPO istiod\n</code></pre> The tutorial requires admission controller in the <code>kyverno-envoy-sidecar-injector</code> namespace that automatically injects the kyverno-envoy-plugin sidecar into pods in namespaces labelled with <code>kyverno-envoy-sidecar/injection=enabled</code>. To install the sidecar-injector admission controller then checkout the installation guide.</p>"},{"location":"tutorials/istio/#creating-a-simple-authorization-policy","title":"Creating a simple authorization policy","text":"<p>This tutorial assumes you have some basic knowledge of validatingPolicy and assertion trees. In summary the policy below does the following:</p> <ul> <li>Checks that the JWT token is valid</li> <li>Checks that the action is allowed based on the token payload <code>role</code> and the request path</li> <li>Guests have read-only access to the <code>/book</code> endpoint, admins can create users too as long as the name is not the same as the admin's name.</li> </ul> <pre><code>apiVersion: json.kyverno.io/v1alpha1\nkind: ValidatingPolicy\nmetadata:\n    name: checkrequest\nspec:\n    rules:\n    - name: deny-guest-request-at-post\n        assert:\n        any:\n        - message: \"POST method calls at path /book are not allowed to guests users\"\n            check:\n            request:\n                http:\n                    method: POST\n                    headers:\n                        authorization:\n                            (split(@, ' ')[1]):\n                                (jwt_decode(@ , 'secret').payload.role): admin\n                    path: /book                             \n        - message: \"GET method call is allowed to both guest and admin users\"\n            check:\n            request:\n                http:\n                    method: GET\n                    headers:\n                        authorization:\n                            (split(@, ' ')[1]):\n                                (jwt_decode(@ , 'secret').payload.role): admin\n                    path: /book \n        - message: \"GET method call is allowed to both guest and admin users\"\n            check:\n            request:\n                http:\n                    method: GET\n                    headers:\n                        authorization:\n                            (split(@, ' ')[1]):\n                                (jwt_decode(@ , 'secret').payload.role): guest\n                    path: /book \n</code></pre>"},{"location":"tutorials/istio/#deploying-the-application","title":"Deploying the application","text":"<p>Create a namespace called demo and label it with <code>istio-injection=enabled</code> to enable sidecar injection:</p> <pre><code>$ kubectl apply -f - &lt;&lt;EOF\napiVersion: v1\nkind: Namespace\nmetadata:\n  name: demo\n  labels:\n    istio-injection: enabled\nEOF\n</code></pre> <p>First we need to apply kyverno policy configmap this policy will be passed to kyverno-envoy-sidecar injector admission controller:</p> <pre><code>$ kubectl apply -f - &lt;&lt;EOF\napiVersion: v1\nkind: ConfigMap\nmetadata:\n  name: policy-files\n  namespace: demo\ndata:\n  policy.yaml: |\n    apiVersion: json.kyverno.io/v1alpha1\n    kind: ValidatingPolicy\n    metadata:\n      name: checkrequest\n    spec:\n      rules:\n        - name: deny-guest-request-at-post\n          assert:\n            any:\n            - message: \"POST method calls at path /book are not allowed to guests users\"\n              check:\n                request:\n                    http:\n                        method: POST\n                        headers:\n                            authorization:\n                                (split(@, ' ')[1]):\n                                    (jwt_decode(@ , 'secret').payload.role): admin\n                        path: /book                             \n            - message: \"GET method call is allowed to both guest and admin users\"\n              check:\n                request:\n                    http:\n                        method: GET\n                        headers:\n                            authorization:\n                                (split(@, ' ')[1]):\n                                    (jwt_decode(@ , 'secret').payload.role): admin\n                        path: /book \n            - message: \"GET method call is allowed to both guest and admin users\"\n              check:\n                request:\n                    http:\n                        method: GET\n                        headers:\n                            authorization:\n                                (split(@, ' ')[1]):\n                                    (jwt_decode(@ , 'secret').payload.role): guest\n                        path: /book               \nEOF                   \n</code></pre> <p>Deploy the sample application which provides information about books in a collection and exposes APIs to get, create and delete Book resources at <code>/book</code> endpoint and make it accessible in the cluster, and enable sidecar injection of the kyverno-envoy-plugin sidecar by adding the <code>kyverno-envoy-sidecar/injection: enabled</code> label to the deployment:</p> <p><pre><code>$ kubectl apply -f - &lt;&lt;EOF\napiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: testapp\n  namespace: demo\nspec:\n  replicas: 1\n  selector:\n    matchLabels:\n      app: testapp\n  template:\n    metadata:\n      labels:\n        kyverno-envoy-sidecar/injection: enabled\n        app: testapp\n    spec:\n      containers:\n      - name: testapp\n        image: sanskardevops/test-application:0.0.1\n        ports:\n        - containerPort: 8080\n---\napiVersion: v1\nkind: Service\nmetadata:\n  name: testapp\n  namespace: demo\nspec:\n  type: ClusterIP\n  selector:\n    app: testapp\n  ports:\n  - port: 8080\n    targetPort: 8080\nEOF\n</code></pre> Check that their should be three containers should be running in the pod.</p> <pre><code>$ kubectl -n demo  get all\nNAME                        READY   STATUS    RESTARTS   AGE\npod/echo-55c77757f4-w6979   3/3     Running   0          3h59m\n\nNAME           TYPE        CLUSTER-IP      EXTERNAL-IP   PORT(S)    AGE\nservice/echo   ClusterIP   10.96.110.173   &lt;none&gt;        8080/TCP   4h5m\n\nNAME                   READY   UP-TO-DATE   AVAILABLE   AGE\ndeployment.apps/echo   1/1     1            1           3h59m\n\nNAME                              DESIRED   CURRENT   READY   AGE\nreplicaset.apps/echo-55c77757f4   1         1         1       3h59m\n</code></pre>"},{"location":"tutorials/istio/#serviceentry","title":"ServiceEntry","text":"<p>ServiceEntry to registor the kyverno-envoy-plugin sidecar as external authorizer and ServiceEntry to allow Istio to find the Kyverno-Envoy-Plugin sidecar.</p> <p><pre><code>kubectl apply -f ./manifests/service-entry.yaml\n</code></pre> <pre><code>apiVersion: networking.istio.io/v1beta1\nkind: ServiceEntry\nmetadata:\n  name: kyverno-ext-authz-grpc-local\nspec:\n  hosts:\n  - \"kyverno-ext-authz-grpc.local\"\n  # The service name to be used in the extension provider in the mesh config.\n  endpoints:\n  - address: \"127.0.0.1\"\n  ports:\n  - name: grpc\n    number: 9000\n    # The port number to be used in the extension provider in the mesh config.\n    protocol: GRPC\n  resolution: STATIC\n</code></pre></p>"},{"location":"tutorials/istio/#register-authorization-provider","title":"Register authorization provider","text":"<p>Edit the mesh configmap to register authorization provider with the following command: </p> <pre><code>kubectl edit configmap istio -n istio-system \n</code></pre> <p>In the editor, add the extension provider definitions to the mesh configmap.</p> <pre><code>  data:\n    mesh: |-   \n      extensionProviders:\n      - name: \"kyverno-ext-authz-grpc\"\n        envoyExtAuthzGrpc:\n          service: \"kyverno-ext-authz-grpc.local\"\n          port: \"9000\"\n</code></pre>"},{"location":"tutorials/istio/#authorization-policy","title":"Authorization policy","text":"<p>AuthorizationPolicy to direct authorization checks to the Kyverno-Envoy-Plugin sidecar.</p> <p><pre><code>$ kubectl apply -f - &lt;&lt;EOF\napiVersion: security.istio.io/v1\nkind: AuthorizationPolicy\nmetadata:\n  name: kyverno-ext-authz-grpc\n  namespace: demo\nspec:\n  action: CUSTOM\n  provider:\n    # The provider name must match the extension provider defined in the mesh config.\n    name: kyverno-ext-authz-grpc\n  rules:\n  # The rules specify when to trigger the external authorizer.\n  - to:\n    # Allowed all path except /healthz\n    - operation:\n        notPaths: [\"/healthz\"]\nEOF \n</code></pre> This policy configures an external service for authorization. Note that the service is not specified directly in the policy but using a <code>provider.name</code> field.</p>"},{"location":"tutorials/istio/#verify-the-authorization","title":"Verify the authorization","text":"<p>For convenience, we\u2019ll want to store Alice\u2019s and Bob\u2019s tokens in environment variables. Here bob is assigned the admin role and alice is assigned the guest role.</p> <pre><code>export ALICE_TOKEN=\"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJleHAiOjIyNDEwODE1MzksIm5iZiI6MTUxNDg1MTEzOSwicm9sZSI6Imd1ZXN0Iiwic3ViIjoiWVd4cFkyVT0ifQ.ja1bgvIt47393ba_WbSBm35NrUhdxM4mOVQN8iXz8lk\"\nexport BOB_TOKEN=\"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJleHAiOjIyNDEwODE1MzksIm5iZiI6MTUxNDg1MTEzOSwicm9sZSI6ImFkbWluIiwic3ViIjoiWVd4cFkyVT0ifQ.veMeVDYlulTdieeX-jxFZ_tCmqQ_K8rwx2OktUHv5Z0\"\n</code></pre> <p>Check for <code>Alice</code> which can get book but cannot create book.</p> <pre><code>kubectl run test -it --rm --restart=Never --image=busybox -- wget -q --header=\"authorization: Bearer \"$ALICE_TOKEN\"\" --output-document - testapp.demo.svc.cluster.local:8080/book\n</code></pre> <p><pre><code>kubectl run test -it --rm --restart=Never --image=busybox -- wget -q --header=\"authorization: Bearer \"$ALICE_TOKEN\"\" --post-data='{\"bookname\":\"Harry Potter\", \"author\":\"J.K. Rowling\"}' --output-document - testapp.demo.svc.cluster.local:8080/book\n</code></pre> Check the <code>Bob</code> which can get book also create the book </p> <pre><code>kubectl run test -it --rm --restart=Never --image=busybox -- wget -q --header=\"authorization: Bearer \"$BOB_TOKEN\"\" --output-document - testapp.demo.svc.cluster.local:8080/book\n</code></pre> <pre><code>kubectl run test -it --rm --restart=Never --image=busybox -- wget -q --header=\"authorization: Bearer \"$BOB_TOKEN\"\" --post-data='{\"bookname\":\"Harry Potter\", \"author\":\"J.K. Rowling\"}' --output-document - testapp.demo.svc.cluster.local:8080/book\n</code></pre> <p>Check on kyverno-envoy-plugin container logs  <pre><code>kubectl logs \"$(kubectl get pod -l app=testapp -n demo -o jsonpath={.items..metadata.name})\" -n demo -c ext-authz -f\n</code></pre></p>"},{"location":"tutorials/istio/#wrap-up","title":"Wrap Up","text":"<p>Congratulations on completing the tutorial!</p> <p>This tutorial demonstrated how to configure Istio\u2019s EnvoyFilter to utilize the kyverno-envoy-plugin as an external authorization service.</p> <p>Additionally, the tutorial provided an example policy using the kyverno-envoy-plugin that returns a boolean decision to determine whether a request should be permitted.</p> <p>Further details about the tutorial can be found here.</p>"},{"location":"tutorials/mtls-istio/","title":"Istio mTLS","text":"<p>Istio is an open source service mesh for managing the different microservices that make up a cloud-native application. Istio provides a mechanism to use a service as an external authorizer with the AuthorizationPolicy API. </p> <p>The kyverno-envoy-plugin is a custom Envoy filter that is used to intercept the incoming request to the service and validate the request using the kyverno engine. </p> <p>In this tutorial we will create a two simple microservices which are going to make external authorization to a single kyverno-envoy-plugin service as a separate pod in the mesh. With this tutorial we are going to understand how to use multiple microservices to make authorization decisions to a single ext-authz server. </p> <p></p> <p>To handle multiple different requests effectively, we leverage the <code>match/exclude</code> declarations to route the specific authz-request to the appropriate validating policy within the Kyverno engine. This approach allows us to execute the right validating policy for each request, enabling efficient and targeted request processing.</p>"},{"location":"tutorials/mtls-istio/#example-policy","title":"Example Policy","text":"<p>The following policies will be executed by the kyverno-envoy-plugin to validate incoming requests made specifically to the <code>testapp-1</code> service. By leveraging the match declarations, we ensure that these policies are executed only when the incoming request is destined for the <code>testapp-1</code> service. This targeted approach allows us to apply the appropriate validation rules and policies based on the specific service being accessed.</p> <p><pre><code>apiVersion: json.kyverno.io/v1alpha1\nkind: ValidatingPolicy\nmetadata:\n  name: test-policy\nspec:\n  rules:\n    - name: deny-external-calls-testapp-1\n      match:\n        any:\n        - request:\n            http:\n                host: 'testapp-1.demo.svc.cluster.local:8080'\n      assert:\n        all:\n        - message: \"The GET method is restricted to the /book path.\"\n          check:\n            request:\n                http:\n                    method: 'GET'\n                    path: '/book'\n</code></pre> To execute the policy when the incoming request is made to <code>testapp-2</code> service we need to use the <code>match</code> declarations.</p> <p><pre><code>apiVersion: json.kyverno.io/v1alpha1\nkind: ValidatingPolicy\nmetadata:\n  name: test-policy\nspec:\n  rules:\n    - name: deny-external-calls-testapp-2\n      match:\n        any:\n        - request:\n            http:\n                host: 'testapp-2.demo.svc.cluster.local:8080'\n      assert:\n        all:\n        - message: \"The GET method is restricted to the /movies path.\"\n          check:\n            request:\n                http:\n                    method: 'GET'\n                    path: '/movie'   \n</code></pre> The example json request for above payload will be like below.</p> <pre><code>{\n  \"source\": {\n    \"address\": {\n      \"socketAddress\": {\n        \"address\": \"10.244.0.71\",\n        \"portValue\": 33880\n      }\n    }\n  },\n  \"destination\": {\n    \"address\": {\n      \"socketAddress\": {\n        \"address\": \"10.244.0.65\",\n        \"portValue\": 8080\n      }\n    }\n  },\n  \"request\": {\n    \"time\": \"2024-05-20T07:52:01.566887Z\",\n    \"http\": {\n      \"id\": \"5415544797791892902\",\n      \"method\": \"GET\",\n      \"headers\": {\n        \":authority\": \"testapp-2.demo.svc.cluster.local:8080\",\n        \":method\": \"GET\",\n        \":path\": \"/movie\",\n        \":scheme\": \"http\",\n        \"user-agent\": \"Wget\",\n        \"x-forwarded-proto\": \"http\",\n        \"x-request-id\": \"a3ad9f03-c9cd-4eab-97d1-83e90e0cee1b\"\n      },\n      \"path\": \"/movie\",\n      \"host\": \"testapp-2.demo.svc.cluster.local:8080\",\n      \"scheme\": \"http\",\n      \"protocol\": \"HTTP/1.1\"\n    }\n  },\n  \"metadataContext\": {},\n  \"routeMetadataContext\": {}\n}\n</code></pre> <p>To enhance security, we can implement Mutual TLS (mTLS) for peer authentication between test services and kyverno-envoy-plugin. Since we are currently using JSON request data to validate incoming requests, there is a potential risk of this data being tampered with during transit. Implementing mTLS would ensure that communication between services is encrypted and authenticated, mitigating the risk of unauthorized data modification.</p> <pre><code>apiVersion: security.istio.io/v1beta1\nkind: PeerAuthentication\nmetadata:\n  name: mtls-demo\n  namespace: demo\nspec:\n  mtls:\n    mode: STRICT\n---\napiVersion: security.istio.io/v1beta1\nkind: PeerAuthentication\nmetadata:\n  name: mtls-testapp-1\n  namespace: demo\nspec:\n  selector:\n    matchLabels:\n      app: testapp-1\n  mtls:\n    mode: STRICT\n  portLevelMtls:\n    8080:\n      mode: PERMISSIVE\n---\napiVersion: security.istio.io/v1beta1\nkind: PeerAuthentication\nmetadata:\n  name: mtls-testapp-2\n  namespace: demo\nspec:\n  selector:\n    matchLabels:\n      app: testapp-2\n  mtls:\n    mode: STRICT\n  portLevelMtls:\n    8080:\n      mode: PERMISSIVE\n</code></pre>"},{"location":"tutorials/mtls-istio/#demo-instructions","title":"Demo instructions","text":""},{"location":"tutorials/mtls-istio/#required-tools","title":"Required tools","text":"<ol> <li><code>kind</code></li> <li><code>kubectl</code></li> <li><code>helm</code></li> </ol>"},{"location":"tutorials/mtls-istio/#create-a-local-cluster-and-install-istio","title":"Create a local cluster and install Istio","text":"<p>The tutorial also requries istio v1.19.0 or later. To install istio, follow the instructions here or run the below script it will create a kind cluster and install istio</p> <pre><code>#!/bin/bash\n\nKIND_IMAGE=kindest/node:v1.29.2\nISTIO_REPO=https://istio-release.storage.googleapis.com/charts\nISTIO_NS=istio-system\n\n# Create Kind cluster\nkind create cluster --image $KIND_IMAGE --wait 1m --config - &lt;&lt;EOF\nkind: Cluster\napiVersion: kind.x-k8s.io/v1alpha4\nnodes:\n  - role: control-plane\n    kubeadmConfigPatches:\n      - |-\n        kind: InitConfiguration\n        nodeRegistration:\n          kubeletExtraArgs:\n            node-labels: \"ingress-ready=true\"\n    extraPortMappings:\n      - containerPort: 80\n        hostPort: 80\n        protocol: TCP\n      - containerPort: 443\n        hostPort: 443\n        protocol: TCP\n  - role: worker\nEOF\n\n# Install Istio components\nhelm upgrade --install istio-base       --namespace $ISTIO_NS           --create-namespace --wait --repo $ISTIO_REPO base\nhelm upgrade --install istiod           --namespace $ISTIO_NS           --create-namespace --wait --repo $ISTIO_REPO istiod\n</code></pre>"},{"location":"tutorials/mtls-istio/#sample-applications","title":"Sample applications","text":"<p>Manifests for the sample applications are available in test-application-1.yaml and test-application-2.yaml. The sample app <code>testapp-1</code> provides information about books in a collection and exposes APIs to get, create and delete Book resources. The sample app <code>testapp-2</code> provides information about movies in a collection and exposes APIs to get, create and delete Movie resources.</p> <pre><code>$ kubectl apply -f - &lt;&lt;EOF\napiVersion: v1\nkind: Namespace\nmetadata:\n  name: demo\n  labels:\n    istio-injection: enabled\nEOF\n</code></pre> <pre><code># test-application-1.yaml\n# Deploy sample application testapp-1 \n$ kubectl apply -f - &lt;&lt;EOF\napiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: testapp-1\n  namespace: demo\nspec:\n  replicas: 1\n  selector:\n    matchLabels:\n      app: testapp-1\n  template:\n    metadata:\n      labels:\n        app: testapp-1\n    spec:\n      containers:\n      - name: testapp-1\n        image: sanskardevops/test-application:0.0.1\n        ports:\n        - containerPort: 8080\n---\napiVersion: v1\nkind: Service\nmetadata:\n  name: testapp-1\n  namespace: demo\nspec:\n  type: NodePort\n  selector:\n    app: testapp-1\n  ports:\n  - port: 8080\n    targetPort: 8080\nEOF\n</code></pre> <pre><code># test-application-2.yaml\n# Deploy sample application testapp-2\n$ kubectl apply -f - &lt;&lt;EOF\napiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: testapp-2\n  namespace: demo\nspec:\n  replicas: 1\n  selector:\n    matchLabels:\n      app: testapp-2\n  template:\n    metadata:\n      labels:\n        app: testapp-2\n    spec:\n      containers:\n      - name: testapp-2\n        image: sanskardevops/test-application-1:0.0.3\n        ports:\n        - containerPort: 8080\n---\napiVersion: v1\nkind: Service\nmetadata:\n  name: testapp-2\n  namespace: demo\nspec:\n  type: ClusterIP\n  selector:\n    app: testapp-2\n  ports:\n  - port: 8080\n    targetPort: 8080\nEOF\n</code></pre>"},{"location":"tutorials/mtls-istio/#calling-the-sample-applications","title":"Calling the sample applications","text":"<p>We are going to call the sample applications using a pod in the cluster.</p> <pre><code>$ kubectl run test -it --rm --restart=Never --image=busybox -- wget -q --output-document - testapp-1.demo.svc.cluster.local:8080/book\n</code></pre> <pre><code>[{\"id\":\"1\",\"bookname\":\"Harry Potter\",\"author\":\"J.K. Rowling\"},{\"id\":\"2\",\"bookname\":\"Animal Farm\",\"author\":\"George Orwell\"}]\npod \"test\" deleted\n</code></pre> <pre><code>$ kubectl run test -it --rm --restart=Never --image=busybox -- wget -q --output-document - testapp-2.demo.svc.cluster.local:8080/movie\n</code></pre> <pre><code>[{\"id\":\"1\",\"Moviename\":\"Inception\",\"Actor\":\"Leonardo DiCaprio\"},{\"id\":\"2\",\"Moviename\":\"Batman\",\"Actor\":\"Jack Nicholson\"}]\npod \"test\" deleted\n</code></pre>"},{"location":"tutorials/mtls-istio/#register-authorization-provider","title":"Register authorization provider","text":"<p>Edit the mesh configmap to register authorization provider with the following command:</p> <p><pre><code>$ kubectl edit configmap istio -n istio-system\n</code></pre> In the editor, add the extension provider definitions to the mesh configmap.</p> <pre><code>  data:\n    mesh: |-   \n      extensionProviders:\n      - name: \"kyverno-ext-authz-grpc\"\n        envoyExtAuthzGrpc:\n          service: \"ext-authz.demo.svc.cluster.local\"\n          port: \"9000\"\n</code></pre>"},{"location":"tutorials/mtls-istio/#authorization-policy","title":"Authorization policy","text":"<p>Now we can deploy an istio <code>AuthorizationPolicy</code>: AuthorizationPolicy to tell Istio to use kyverno-envoy-plugin as the Authz Server</p> <pre><code>$ kubectl apply -f - &lt;&lt;EOF\napiVersion: security.istio.io/v1\nkind: AuthorizationPolicy\nmetadata:\n  name: kyverno-ext-authz-grpc\n  namespace: demo\nspec:\n  action: CUSTOM\n  provider:\n    # The provider name must match the extension provider defined in the mesh config.\n    name: kyverno-ext-authz-grpc\n  rules:\n  # The rules specify when to trigger the external authorizer.\n  - to:\n    - operation:\n        paths: [\"/book\",\"/movie\"]\nEOF        \n</code></pre> <p>This policy configures an external service for authorization. Note that the service is not specified directly in the policy but using a provider.name field. The rules specify that requests to paths <code>/book</code> and <code>/movies</code>.</p>"},{"location":"tutorials/mtls-istio/#authorization-service-deployment","title":"Authorization service deployment","text":"<p>The deployment manifest of the authorization service is available in ext-auth-server.yaml. This deployment require policy through configmap .</p> <p>Apply the policy configmap with the following command.</p> <pre><code>$ kubectl apply -f - &lt;&lt;EOF\napiVersion: v1\nkind: ConfigMap\nmetadata:\n  name: policy-files\n  namespace: demo\ndata:\n  policy1.yaml: |\n    apiVersion: json.kyverno.io/v1alpha1\n    kind: ValidatingPolicy\n    metadata:\n      name: test-policy\n    spec:\n      rules:\n        - name: deny-external-calls-testapp-1\n          match:\n            any:\n            - request:\n                http:\n                    host: 'testapp-1.demo.svc.cluster.local:8080'\n          assert:\n            all:\n            - message: \"The GET method is restricted to the /book path.\"\n              check:\n                request:\n                    http:\n                        method: 'GET'\n                        path: '/book'\n  policy2.yaml: |\n    apiVersion: json.kyverno.io/v1alpha1\n    kind: ValidatingPolicy\n    metadata:\n      name: test-policy\n    spec:\n      rules:\n        - name: deny-external-calls-testapp-2\n          match:\n            any:\n            - request:\n                http:\n                    host: 'testapp-2.demo.svc.cluster.local:8080'\n          assert:\n            all:\n            - message: \"The GET method is restricted to the /movies path.\"\n              check:\n                request:\n                    http:\n                        method: 'GET'\n                        path: '/movie'                \nEOF                        \n</code></pre> <pre><code># ext-auth-server.yaml\n# Deploy the kyverno external authorizer server\n$ kubectl apply -f - &lt;&lt;EOF\napiVersion: v1\nkind: Service\nmetadata:\n  name: ext-authz\n  labels:\n    app: ext-authz\n  namespace: demo  \nspec:\n  ports:\n  - name: http\n    port: 8000\n    targetPort: 8000\n  - name: grpc\n    port: 9000\n    targetPort: 9000\n  selector:\n    app: ext-authz\n---\napiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: ext-authz\n  namespace: demo \nspec:\n  replicas: 1\n  selector:\n    matchLabels:\n      app: ext-authz \n  template:\n    metadata:\n      labels:\n        app: ext-authz\n    spec:\n      containers:\n      - image: sanskardevops/plugin:0.0.29\n        imagePullPolicy: IfNotPresent\n        name: ext-authz\n        ports:\n        - containerPort: 8000\n        - containerPort: 9000\n        args:\n        - \"serve\"\n        - \"--policy=/policies/policy1.yaml\"\n        - \"--policy=/policies/policy2.yaml\"\n        volumeMounts:\n        - name: policy-files\n          mountPath: /policies\n      volumes:\n      - name: policy-files\n        configMap:\n          name: policy-files\nEOF\n</code></pre> <p>Verify the sample external authorizer is up and running: <pre><code>$ kubectl logs \"$(kubectl get pod -l app=ext-authz -n demo -o jsonpath={.items..metadata.name})\" -n demo -c ext-authz -f\n</code></pre></p> <pre><code>Starting GRPC server on Port 9000\nStarting HTTP server on Port 8000\n</code></pre>"},{"location":"tutorials/mtls-istio/#apply-peerauthentication-policy","title":"Apply PeerAuthentication Policy","text":"<p>Apply the PeerAuthentication policy to enable mTLS for the sample applications and external authorizer.</p> <pre><code>$ kubectl apply -f - &lt;&lt;EOF\napiVersion: security.istio.io/v1beta1\nkind: PeerAuthentication\nmetadata:\n  name: mtls-demo\n  namespace: demo\nspec:\n  mtls:\n    mode: STRICT\n---\napiVersion: security.istio.io/v1beta1\nkind: PeerAuthentication\nmetadata:\n  name: mtls-testapp-1\n  namespace: demo\nspec:\n  selector:\n    matchLabels:\n      app: testapp-1\n  mtls:\n    mode: STRICT\n  portLevelMtls:\n    8080:\n      mode: PERMISSIVE\n---\napiVersion: security.istio.io/v1beta1\nkind: PeerAuthentication\nmetadata:\n  name: mtls-testapp-2\n  namespace: demo\nspec:\n  selector:\n    matchLabels:\n      app: testapp-2\n  mtls:\n    mode: STRICT\n  portLevelMtls:\n    8080:\n      mode: PERMISSIVE\nEOF\n</code></pre>"},{"location":"tutorials/mtls-istio/#test-the-sample-applications","title":"Test the sample applications","text":"<p>Check on the logs of the sample applications to see that the requests are accepted and rejected</p> <p>Check on <code>GET</code> request on <code>testapp-1</code> which is allowed according to policy <code>deny-external-calls-testapp-1</code></p> <pre><code>$ kubectl run test -it --rm --restart=Never --image=busybox -- wget -q --output-document - testapp-1.demo.svc.cluster.local:8080/book\n</code></pre> <pre><code>[{\"id\":\"1\",\"bookname\":\"Harry Potter\",\"author\":\"J.K. Rowling\"},{\"id\":\"2\",\"bookname\":\"Animal Farm\",\"author\":\"George Orwell\"}]\npod \"test\" deleted\n</code></pre> <p>Check on <code>GET</code> request on <code>testapp-2</code> which is allowed according to policy <code>deny-external-calls-testapp-2</code></p> <pre><code>$ kubectl run test -it --rm --restart=Never --image=busybox -- wget -q --output-document - testapp-2.demo.svc.cluster.local:8080/movie\n</code></pre> <pre><code>[{\"id\":\"1\",\"Moviename\":\"Inception\",\"Actor\":\"Leonardo DiCaprio\"},{\"id\":\"2\",\"Moviename\":\"Batman\",\"Actor\":\"Jack Nicholson\"}]\npod \"test\" deleted\n</code></pre> <p>Check logs of external authorizer to see that the requests are which policy was executed for a perticular request .</p> <pre><code>$ kubectl logs \"$(kubectl get pod -l app=ext-authz -n demo -o jsonpath={.items..metadata.name})\" -n demo -c ext-authz -f\n</code></pre> <p><pre><code>Starting GRPC server on Port 9000\nStarting HTTP server on Port 8000\n2024/05/21 07:41:33 Request is initialized in kyvernojson engine .\n2024/05/21 07:41:33 Request passed the deny-external-calls-testapp-1 policy rule.\n2024/05/21 07:42:22 Request is initialized in kyvernojson engine .\n2024/05/21 07:42:22 Request passed the deny-external-calls-testapp-2 policy rule.\n</code></pre> First request was directed to testapp-1 which was allowed by the policy <code>deny-external-calls-testapp-1</code> and the second request was directed to testapp-2 which was allowed by the policy <code>deny-external-calls-testapp-2</code>.</p>"},{"location":"tutorials/mtls-istio/#wrap-up","title":"Wrap Up","text":"<p>Congratulations on completing the tutorial!</p> <p>This tutorial demonstrated how to configure Istio's AuthorizationPolicy to utilize the kyverno-envoy-plugin as an separate pod external authorization service. By leveraging the power of Kyverno's policy engine, you can enforce fine-grained authorization rules across your microservices within the Istio service mesh.</p> <p>Additionally, the tutorial showcased the use of mTLS (Mutual TLS) to secure communication between services and the kyverno-envoy-plugin, ensuring end-to-end encryption and authentication.</p> <p>The combination of Istio's AuthorizationPolicy and the kyverno-envoy-plugin provides a flexible and powerful solution for implementing custom authorization logic in your cloud-native applications. By following this tutorial, you've gained hands-on experience in configuring and deploying this solution, setting the stage for further exploration and customization to meet your specific requirements.</p> <p>We hope this tutorial has been informative and has provided you with a solid foundation for integrating the kyverno-envoy-plugin into your Istio service mesh environment. Feel free to explore the project's documentation and community resources for further assistance and to stay updated with the latest developments.</p>"},{"location":"tutorials/standalone-envoy/","title":"Standalone Envoy","text":"<p>The tutorial shows how Envoy's External Authorization filter can be used with Kyverno as an authorization service to enforce security policies over API requests received by Envoy.</p>"},{"location":"tutorials/standalone-envoy/#overview","title":"Overview","text":"<p>In this tutorial we'll see how to use Kyverno-envoy-plugin as an External Authorization service for the Envoy proxy. The goal of the demo to show user how kyverno-envoy-plugin will work with standalone envoy and how it can be used to enforce policies to the traffic between services. The Kyverno-envoy-plugin allows configuring these Envoy proxies to query Kyverno-json for policy decisions on incoming requests. The kyverno-envoy-plugin is cofigured as a static binary and can be run as a sidecar container in the same pod as the application.</p> <p>We'll do this by:</p> <ul> <li>Running a local Kubernetes cluster</li> <li>Creating a simple authorization policy in ValidatingPolicy </li> <li>Deploying a sample application with Envoy and kyverno-envoy-plugin sidecars</li> <li>Run some sample requests to see the policy in action</li> </ul> <p>Note that other than the HTTP client and bundle server, all components are co-located in the same pod.</p>"},{"location":"tutorials/standalone-envoy/#demo-instructions","title":"Demo instructions","text":""},{"location":"tutorials/standalone-envoy/#required-tools","title":"Required tools","text":"<ol> <li><code>kind</code></li> <li><code>kubectl</code></li> </ol> <p>{{&lt; info &gt;}} If you haven't used <code>kind</code> before, you can find installation instructions in the project documentation. {{&lt;/ info &gt;}}</p>"},{"location":"tutorials/standalone-envoy/#running-a-local-kubernetes-cluster","title":"Running a local Kubernetes cluster","text":"<p>To start a local kubernetes cluster to run our demo, we'll be using kind. In order to use the kind command, you\u2019ll need to have Docker installed on your machine. </p> <p>Create a cluster with the following command:</p> <pre><code>$ kind create cluster --name kyverno-tutorial --image kindest/node:v1.29.2\nCreating cluster \"kyverno-tutorial\" ...\n \u2713 Ensuring node image (kindest/node:v1.29.2) \ud83d\uddbc\n \u2713 Preparing nodes \ud83d\udce6  \n \u2713 Writing configuration \ud83d\udcdc \n \u2713 Starting control-plane \ud83d\udd79\ufe0f \n \u2713 Installing CNI \ud83d\udd0c \n \u2713 Installing StorageClass \ud83d\udcbe \nSet kubectl context to \"kind-kyverno-tutorial\"\nYou can now use your cluster with:\n\nkubectl cluster-info --context kind-kyverno-tutorial\n\nThanks for using kind! \ud83d\ude0a\n</code></pre> <p>Listing the cluster nodes, should show something like this:</p> <pre><code>$ kubectl get nodes\nNAME                             STATUS   ROLES           AGE   VERSION\nkyverno-tutorial-control-plane   Ready    control-plane   79s   v1.29.2\n</code></pre>"},{"location":"tutorials/standalone-envoy/#creating-a-simple-authorization-policy","title":"Creating a simple authorization policy","text":"<p>This tutorial assumes you have some basic knowledge of validatingPolicy and assertion trees. In summary the policy below does the following:</p> <ul> <li>Checks that the JWT token is valid</li> <li>Checks that the action is allowed based on the token payload <code>role</code> and the request path</li> <li>Guests have read-only access to the <code>/book</code> endpoint, admins can create users too as long as the name is not the same as the admin's name.</li> </ul> <pre><code>apiVersion: json.kyverno.io/v1alpha1\nkind: ValidatingPolicy\nmetadata:\n    name: checkrequest\nspec:\n    rules:\n    - name: deny-guest-request-at-post\n        assert:\n        any:\n        - message: \"POST method calls at path /book are not allowed to guests users\"\n            check:\n            request:\n                http:\n                    method: POST\n                    headers:\n                        authorization:\n                            (split(@, ' ')[1]):\n                                (jwt_decode(@ , 'secret').payload.role): admin\n                    path: /book                             \n        - message: \"GET method call is allowed to both guest and admin users\"\n            check:\n            request:\n                http:\n                    method: GET\n                    headers:\n                        authorization:\n                            (split(@, ' ')[1]):\n                                (jwt_decode(@ , 'secret').payload.role): admin\n                    path: /book \n        - message: \"GET method call is allowed to both guest and admin users\"\n            check:\n            request:\n                http:\n                    method: GET\n                    headers:\n                        authorization:\n                            (split(@, ' ')[1]):\n                                (jwt_decode(@ , 'secret').payload.role): guest\n                    path: /book \n</code></pre> <p>Create a file called policy.yaml with the above content and store it in a configMap:</p> <pre><code>$ kubectl create configmap policy --from-file=policy.yaml\n</code></pre>"},{"location":"tutorials/standalone-envoy/#deploying-an-application-with-envoy-and-kyverno-envoy-plugin-sidecars","title":"Deploying an application with Envoy and Kyverno-Envoy-Plugin sidecars","text":"<p>In this tutorial, we are manually configuring the Envoy proxy sidecar to intermediate HTTP traffic from clients and our application. Envoy will consult Kyverno-Envoy-Plugin to make authorization decisions for each request by sending <code>CheckRequest</code> gRPC messages over a gRPC connection.</p> <p>We will use the following Envoy configuration to achieve this. In summary, this configures Envoy to:</p> <ul> <li>Listen on Port <code>7000</code> for HTTP traffic</li> <li>Consult Kyverno-Envoy-Plugin at <code>127.0.0.1:9000</code> for authorization decisions and deny failing requests</li> <li>Forward request to the application at <code>127.0.0.1:8080</code> if ok.</li> </ul> <pre><code>    static_resources:\n      listeners:\n      - address:\n          socket_address:\n            address: 0.0.0.0\n            port_value: 7000\n        filter_chains:\n        - filters:\n          - name: envoy.filters.network.http_connection_manager\n            typed_config:\n              \"@type\": type.googleapis.com/envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager\n              codec_type: auto\n              stat_prefix: ingress_http\n              route_config:\n                name: local_route\n                virtual_hosts:\n                - name: backend\n                  domains:\n                  - \"*\"\n                  routes:\n                  - match:\n                      prefix: \"/\"\n                    route:\n                      cluster: service\n              http_filters:\n              - name: envoy.ext_authz\n                typed_config:\n                  \"@type\": type.googleapis.com/envoy.extensions.filters.http.ext_authz.v3.ExtAuthz\n                  transport_api_version: V3\n                  with_request_body:\n                    max_request_bytes: 8192\n                    allow_partial_message: true\n                  failure_mode_allow: false\n                  grpc_service:\n                    google_grpc:\n                      target_uri: 127.0.0.1:9000\n                      stat_prefix: ext_authz\n                    timeout: 0.5s\n              - name: envoy.filters.http.router\n                typed_config:\n                  \"@type\": type.googleapis.com/envoy.extensions.filters.http.router.v3.Router\n      clusters:\n      - name: service\n        connect_timeout: 0.25s\n        type: strict_dns\n        lb_policy: round_robin\n        load_assignment:\n          cluster_name: service\n          endpoints:\n          - lb_endpoints:\n            - endpoint:\n                address:\n                  socket_address:\n                    address: 127.0.0.1\n                    port_value: 8080\n    admin:\n      access_log_path: \"/dev/null\"\n      address:\n        socket_address:\n          address: 0.0.0.0\n          port_value: 8001\n    layered_runtime:\n      layers:\n        - name: static_layer_0\n          static_layer:\n            envoy:\n              resource_limits:\n                listener:\n                  example_listener_name:\n                    connection_limit: 10000\n            overload:\n              global_downstream_max_connections: 50000\n</code></pre> <p>Create a <code>ConfigMap</code> containing the above configuration by running:</p> <p><pre><code>$ kubectl create configmap proxy-config --from-file envoy.yaml \n</code></pre> Our application will be configured using a <code>Deployment</code> and <code>Service</code>. There are few things to note:</p> <ul> <li>The pods have an <code>initContainer</code> that configures the <code>iptables</code> rules to redirect traffic to the Envoy Proxy sidecar.</li> <li>The <code>test-application</code> container is simple go application stores book information in-memory state.</li> <li>The <code>envoy</code> container is configured to use <code>proxy-config</code> <code>ConfigMap</code> as the Envoy configuration we created earlier</li> <li>The <code>kyverno-envoy-plugin</code> container is configured to use <code>policy</code> <code>ConfigMap</code> as the Kyverno policy we created earlier</li> </ul> <pre><code># test-application.yaml\napiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: testapp\n  namespace: demo\nspec:\n  replicas: 1\n  selector:\n    matchLabels:\n      app: testapp\n  template:\n    metadata:\n      labels:\n        app: testapp\n    spec:\n      initContainers:\n        - name: proxy-init\n          image: sanskardevops/proxyinit:latest\n          # Configure the iptables bootstrap script to redirect traffic to the\n          # Envoy proxy on port 8000, specify that Envoy will be running as user\n          # 1111, and that we want to exclude port 8181 from the proxy for the Kyverno health checks.\n          # These values must match up with the configuration\n          # defined below for the \"envoy\" and \"kyverno-envoy-plugin\" containers.\n          args: [\"-p\", \"7000\", \"-u\", \"1111\", -w, \"8181\"]\n          securityContext:\n            capabilities:\n              add:\n                - NET_ADMIN\n            runAsNonRoot: false\n            runAsUser: 0\n      containers:\n        - name: test-application\n          image: sanskardevops/test-application:0.0.1\n          ports:\n            - containerPort: 8080\n        - name: envoy\n          image: envoyproxy/envoy:v1.30-latest\n          securityContext:\n            runAsUser: 1111\n          imagePullPolicy: IfNotPresent\n          volumeMounts:\n            - readOnly: true\n              mountPath: /config\n              name: proxy-config\n          args:\n            - \"envoy\"\n            - \"--config-path\"\n            - \"/config/envoy.yaml\"\n        - name: kyverno-envoy-plugin\n          image: sanskardevops/plugin:0.0.34\n          imagePullPolicy: IfNotPresent\n          ports:\n            - containerPort: 8181\n            - containerPort: 9000\n          volumeMounts:\n            - readOnly: true\n              mountPath: /policies\n              name: policy-files\n          args:\n            - \"serve\"\n            - \"--policy=/policies/policy.yaml\"\n            - \"--address=:9000\"\n            - \"--healthaddress=:8181\"\n          livenessProbe:\n            httpGet:\n              path: /health\n              scheme: HTTP\n              port: 8181\n            initialDelaySeconds: 5\n            periodSeconds: 5\n          readinessProbe:\n            httpGet:\n              path: /health\n              scheme: HTTP\n              port: 8181\n            initialDelaySeconds: 5\n            periodSeconds: 5  \n      volumes:\n        - name: proxy-config\n          configMap:\n            name: proxy-config\n        - name: policy-files\n          configMap:\n            name: policy-files\n---\napiVersion: v1\nkind: Service\nmetadata:\n  name: testapp\n  namespace: demo\nspec:\n  type: ClusterIP\n  selector:\n    app: testapp\n  ports:\n  - port: 8080\n    targetPort: 8080      \n</code></pre> <p>Deploy the application and Kubernetes Service to the cluster with:</p> <p><pre><code>$ kubectl apply -f test-application.yaml\n</code></pre> Check that everything is working by listing the pod and make sure all three pods are running ok.</p> <pre><code>$ kubectl get pods\nNAME                         READY   STATUS    RESTARTS   AGE\ntestapp-74b4bc88-5d4wh       3/3     Running   0          1m\n</code></pre>"},{"location":"tutorials/standalone-envoy/#policy-in-action","title":"Policy in action","text":"<p>For convenience, we\u2019ll want to store Alice\u2019s and Bob\u2019s tokens in environment variables. Here bob is assigned the admin role and alice is assigned the guest role.</p> <pre><code>export ALICE_TOKEN=\"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJleHAiOjIyNDEwODE1MzksIm5iZiI6MTUxNDg1MTEzOSwicm9sZSI6Imd1ZXN0Iiwic3ViIjoiWVd4cFkyVT0ifQ.ja1bgvIt47393ba_WbSBm35NrUhdxM4mOVQN8iXz8lk\"\nexport BOB_TOKEN=\"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJleHAiOjIyNDEwODE1MzksIm5iZiI6MTUxNDg1MTEzOSwicm9sZSI6ImFkbWluIiwic3ViIjoiWVd4cFkyVT0ifQ.veMeVDYlulTdieeX-jxFZ_tCmqQ_K8rwx2OktUHv5Z0\"\n</code></pre> <p>Check for <code>Alice</code> which can get book but cannot create book.</p> <p><pre><code>kubectl run test -it --rm --restart=Never --image=busybox -- wget -q --header=\"authorization: Bearer \"$ALICE_TOKEN\"\" --output-document - testapp.demo.svc.cluster.local:8080/book\n</code></pre> <pre><code>kubectl run test -it --rm --restart=Never --image=busybox -- wget -q --header=\"authorization: Bearer \"$ALICE_TOKEN\"\" --post-data='{\"bookname\":\"Harry Potter\", \"author\":\"J.K. Rowling\"}' --output-document - testapp.demo.svc.cluster.local:8080/book\n</code></pre> Check the <code>Bob</code> which can get book also create the book </p> <pre><code>kubectl run test -it --rm --restart=Never --image=busybox -- wget -q --header=\"authorization: Bearer \"$BOB_TOKEN\"\" --output-document - testapp.demo.svc.cluster.local:8080/book\n</code></pre> <pre><code>kubectl run test -it --rm --restart=Never --image=busybox -- wget -q --header=\"authorization: Bearer \"$BOB_TOKEN\"\" --post-data='{\"bookname\":\"Harry Potter\", \"author\":\"J.K. Rowling\"}' --output-document - testapp.demo.svc.cluster.local:8080/book\n</code></pre> <p>Check on logs  <pre><code>kubectl logs \"$(kubectl get pod -l app=testapp -n demo -o jsonpath={.items..metadata.name})\" -n demo -c kyverno-envoy-plugin -f\n</code></pre> First , third and last request is passed but second request is failed.</p> <pre><code>sanskar@sanskar-HP-Laptop-15s-du1xxx:~$ kubectl logs \"$(kubectl get pod -l app=testapp -n demo -o jsonpath={.items..metadata.name})\" -n demo -c kyverno-envoy-plugin -f\nStarting HTTP server on Port 8000\nStarting GRPC server on Port 9000\nRequest is initialized in kyvernojson engine .\n2024/04/26 17:11:42 Request passed the deny-guest-request-at-post policy rule.\nRequest is initialized in kyvernojson engine .\n2024/04/26 17:22:11 Request violation: -&gt; POST method calls at path /book are not allowed to guests users\n -&gt; any[0].check.request.http.headers.authorization.(split(@, ' ')[1]).(jwt_decode(@ , 'secret').payload.role): Invalid value: \"guest\": Expected value: \"admin\"\n-&gt; GET method call is allowed to both guest and admin users\n -&gt; any[1].check.request.http.headers.authorization.(split(@, ' ')[1]).(jwt_decode(@ , 'secret').payload.role): Invalid value: \"guest\": Expected value: \"admin\"\n -&gt; any[1].check.request.http.method: Invalid value: \"POST\": Expected value: \"GET\"\n-&gt; GET method call is allowed to both guest and admin users\n -&gt; any[2].check.request.http.method: Invalid value: \"POST\": Expected value: \"GET\"\nRequest is initialized in kyvernojson engine .\n2024/04/26 17:23:13 Request passed the deny-guest-request-at-post policy rule.\nRequest is initialized in kyvernojson engine .\n2024/04/26 17:23:55 Request passed the deny-guest-request-at-post policy rule.\n</code></pre>"},{"location":"tutorials/standalone-envoy/#cleanup","title":"Cleanup","text":"<p>Delete the cluster by running: <pre><code>$ kind delete cluster --name kyverno-tutorial\n</code></pre></p>"},{"location":"tutorials/standalone-envoy/#wrap-up","title":"Wrap Up","text":"<p>Congratulations on completing the tutorial!</p> <p>In this tutorial, you learned how to utilize the kyverno-envoy-plugin as an external authorization service to enforce custom policies through Envoy\u2019s external authorization filter.</p> <p>The tutorial also included an example policy using kyverno-envoy-plugin that returns a boolean decision indicating whether a request should be permitted.</p> <p>Moreover, Envoy\u2019s external authorization filter supports the inclusion of optional response headers and body content that can be sent to either the downstream client or upstream server. An example of a rule that not only determines request authorization but also provides optional response headers, body content, and HTTP status is available here.</p>"}]}